<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[new一个对象的过程]]></title>
      <url>/2017/07/31/js_new%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>(1) 创建一个新对象</p>
<p>(2) 将构造函数的作用域赋给新对象，（因此this就指向了这个对象）</p>
<p>(3) 执行代码，即对this赋值</p>
<p>(4) 返回this</p>
<pre><code>//例子
function Foo(name,age){
    this.name=name;                    //(3)
    this.age=age;                    //(3)
    this.class=&quot;class-1&quot;;            //(3)
    //return this;        //默认有这一行(4)
}

var f1 = new Foo(&quot;zhangsan&quot;,23);    //(1)(2)
</code></pre><h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><h3 id="对象字面量的方式"><a href="#对象字面量的方式" class="headerlink" title="对象字面量的方式"></a>对象字面量的方式</h3><pre><code>var person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};
</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><pre><code>//工厂模式用函数来封装以特定接口创建对象的细节
function createPerson(name,age,job){
    var o=new Object();
    o.name=name;
    o.age=age;
    o.job=job;

    o.sayHi=function(){
        console.log(this.name);
    };
    return o;
}

var person1=createPerson(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);
person1.sayHi();//Nicholas
var person2=createPerson(&quot;Grey&quot;,27,&quot;Doctor&quot;);
person2.sayHi();//Grey
</code></pre><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>如下所示，在这个例子中，Person()函数取代了createPerson()函数。我们注意到，它俩的不同之处：<br><br>（1）没有显示地创建对象<br><br>（2）直接将属性和方法赋给了this对象<br><br>（3）没有return语句</p>
<pre><code>function Person(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;
    this.sayName=function(){
        console.log(this.name);
    };
}

var person1=new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);
var person2=new Person(&quot;Grey&quot;,27,&quot;Doctor&quot;);
</code></pre><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><pre><code>//利用函数的原型属性（prototype属性）
function Person(){

}
Person.prototype.name=&quot;Nicholas&quot;;
Person.prototype.age=29;
Person.prototype.job=&quot;SoftWare Engineer&quot;;
Person.prototype.sayName=function(){
    console.log(this.name);
}

var person1=new Person();
person1.sayName();//Nicholas

var person2=new Person();
person2.sayName();//Nicholas

console.log(person1.sayName==person2.sayName);//true

//可以利用isPrototypeOf()来判断对象之间是否存在原型系统与实例间的关系
console.log(Person.prototype.isPrototypeOf(person1));//true
</code></pre><h3 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h3><pre><code>//组合使用构造函数模式与原型模式，
function Person(name,age,job){
    this.name=name;
    this.age=age;
    this,job=job;
    this.friends=[&quot;Shelby&quot;,&quot;Court&quot;];
}

Person.prototype={
    constructor:Person,
    sayName:function(){
        console.log(this.name);
    }
}

var person1=new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);
var person2=new Person(&quot;Grey&quot;,21,&quot;Doctor&quot;);

person1.friends.push(&quot;Van&quot;);
console.log(person1.friends);//[ &apos;Shelby&apos;, &apos;Court&apos;, &apos;Van&apos; ]
console.log(person2.friends);//[ &apos;Shelby&apos;, &apos;Court&apos; ]

console.log(person1.friends===person2.friends);//false
console.log(person1.sayName===person2.sayName);//true
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> new，面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原型和原型链]]></title>
      <url>/2017/07/31/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<h3 id="原型规则"><a href="#原型规则" class="headerlink" title="原型规则"></a>原型规则</h3><blockquote>
<ol>
<li>所有的引用类型变量（对象，数组、函数），都有构造函数</li>
<li>所有引用类型变量（对象，数组、函数），都具有对象特性，即可自由扩展属性。</li>
<li>所有引用类型变量（对象，数组、函数），都有一个隐式原型属性（<strong>proto</strong>）,属性值也是一个普通的对象。</li>
<li><strong>所有函数</strong>都有一个显示原型属性（prototype)，属性值也是一个普通的对象。</li>
<li>当试图得到一个引用类型的某个属性是，如果这个对象本身没有这个属性，那么会去它的<strong>proto</strong>（即它的构造函数的prototype）中寻找。</li>
</ol>
</blockquote>
<h3 id="一个原型链继承的例子"><a href="#一个原型链继承的例子" class="headerlink" title="一个原型链继承的例子"></a>一个原型链继承的例子</h3><pre><code>function Elem(id){
    this.elem=document.getElementById(id);
}

Elme.prototype.html=function(var){
    var elem=this.elem;
    if(var){
        elem.innerHTML=val;
        return this;
    }else{
        return elem.innerHTML;
    }
}
Elem.prototype.on=function(type,fn){
    var elem=this.elem;
    elem.addEventListener(type,fn);
}
//实例
var div1=new Elem(&quot;div1&quot;);
div1.html(&quot;&lt;p&gt;hello&lt;/p&gt;&quot;);
div1.on(&apos;click&apos;,function(){
    alert(&apos;clicked&apos;);
});
</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>因 typeof 只能判断值类型数据的变量类型，但如果变量的值是一个对象或者null，则判断不了。为此提供了 instanceof 操作符，其语法如下所示</p>
<pre><code>result = variable instanceof constructor
//例如：
alert(person instanceof Object);
alert(colors instanceof Array);
alert(pattern instanceof RegExp);
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js基础知识，面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript数据类型]]></title>
      <url>/2017/07/31/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>Javascript按存储方式区分变量类型：值类型（也称基本数据类型）和引用数据类型。</p>
<h3 id="1-基本数据（值）类型"><a href="#1-基本数据（值）类型" class="headerlink" title="1.基本数据（值）类型"></a>1.基本数据（值）类型</h3><p>字符串型（String）；数值型（Number）;布尔型（Boolean）;未定义（undefined）；Null类型</p>
<h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h3><p>对象（Object）类型；数组类型（Array）；函数类型（function）</p>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><p>基本数据类型的变量存放的是基本类型数据的实际值；而引用数据类型的变量保存对它的引用，即指针。<br><br>引用数据类型好几个变量共用一个内存块，赋值一旦被修改，互相会有影响。</p>
<h3 id="4-需注意"><a href="#4-需注意" class="headerlink" title="4.需注意"></a>4.需注意</h3><p>(1) <strong>typeof</strong>只能区分值类型的详细类型，如果这个值是引用数据类型或者null，则区分不出来</p>
<pre><code>typeof 95            //&quot;number&quot;
typeof &apos;aa&apos;            //&quot;string&quot;
typeof true            //&quot;boolean&quot;
typeof undefined    //&quot;undefined&quot;
typeof null            //&quot;object&quot;

var o= new Object();
typeof o            //&quot;object&quot;
</code></pre><p>(2) <strong>null==undefined会返回true,但null===undefined会返回false。</strong>那么编码过程中，什么时候用“==”，什么时候用“===”呢？</p>
<p>a.对象的属性是否存在    </p>
<pre><code>if(obj.a==null){
    //这里相当于obj.a===null||obj.a==undefined，简写形式
    //这是jQuery源码中的推荐写法
}
</code></pre><p>b.函数的参数a是否存在</p>
<pre><code>function(a,b){
    if(a==null){
        ...
    }
}
</code></pre><font color="red">其他情况都用“===”。</font>

<p>(3)怎么判断一个变量a在if语句中是true还是false?</p>
<pre><code>!!(a);
</code></pre><font color="red">注：</font> 0，NaN，’’，null，false，undefined–&gt;会转换为false<br><br>(4)JS中的内置函数：Object，Array，Boolean，Number，String，Function，Date，RegExp，Error…<br><font color="red">Math是内置对象，不是函数。</font>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js数据类型 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2014/03/16/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
