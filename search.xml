<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[将url附带的参数转换为对象返回]]></title>
      <url>/2017/08/03/%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9A%E5%B0%86url%E9%99%84%E5%B8%A6%E7%9A%84%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AF%B9%E8%B1%A1%E8%BF%94%E5%9B%9Emd/</url>
      <content type="html"><![CDATA[<p>面试题：有一个页面，url为’<a href="http://qq.com?pet=cat&amp;age=2&amp;like=fish&#39;,设计一个函数将url附带的参数转换为对象返回" target="_blank" rel="external">http://qq.com?pet=cat&amp;age=2&amp;like=fish&#39;,设计一个函数将url附带的参数转换为对象返回</a></p>
<pre><code>function getParamObj(url){
    var startIndex =url.indexOf(&apos;?&apos;)+1;
    var subParam=url.substring(startIndex,url.length);
    var arrParam=subParam.split(&apos;&amp;&apos;);
    var objParam=new Object();//注意：初始化一个对象
    for(var i=0;i&lt;arrParam.length;i++){
        var arrSingle=arrParam[i].split(&apos;=&apos;);
        objParam[arrSingle[0]]=arrSingle[1];//注意：对象属性的赋值方法obj[key]=value
    }
    return objParam;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BOM操作]]></title>
      <url>/2017/08/03/BOM%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="一、如何检测浏览器的类型"><a href="#一、如何检测浏览器的类型" class="headerlink" title="一、如何检测浏览器的类型"></a>一、如何检测浏览器的类型</h3><p><strong>navigator对象</strong></p>
<blockquote>
<table table="" cellspacing="0" style="border:1px solid #e6e6e6;text-align:left"><tr><th>属性</th><th>描述</th></tr><tr><td>appCodeName</td><td>返回浏览器的代码名。</td></tr><tr><td>appMinorVersion</td><td>返回浏览器的次级版本。</td></tr><tr><td>appName</td><td>返回浏览器的名称。</td></tr><tr><td>appVersion</td><td>返回浏览器的平台和版本信息。</td></tr><tr><td>browserLanguage</td><td>返回当前浏览器的语言。</td></tr><tr><td>cookieEnabled</td><td>返回指明浏览器中是否启用 cookie 的布尔值。</td></tr><tr><td>cpuClass</td><td>返回浏览器系统的 CPU 等级。</td></tr><tr><td>onLine</td><td>返回指明系统是否处于脱机模式的布尔值。</td></tr><tr><td>platform</td><td>返回运行浏览器的操作系统平台。</td></tr><tr><td>systemLanguage</td><td>返回 OS 使用的默认语言。</td></tr><tr><td>userAgent</td><td>返回由客户机发送服务器的 user-agent 头部的值。</td></tr><tr><td>userLanguage</td><td>返回 OS 的自然语言设置。</td></tr></table>

</blockquote>
<pre><code>var ua=navigator.userAgent;
var reg=/chrome/i;
var isChrome=reg.test(ua);
console.log(isChrome);
</code></pre><h3 id="二、拆解url的各个部分"><a href="#二、拆解url的各个部分" class="headerlink" title="二、拆解url的各个部分"></a>二、拆解url的各个部分</h3><p><strong>location对象</strong></p>
<blockquote>
<table table="" cellspacing="0" style="border:1px solid #e6e6e6;text-align:left"><tr><th>属性</th><th>例子</th><th>描述</th></tr><tr><td>href</td><td>“<a href="http://www.wrox.com/WileyCDA/" target="_blank" rel="external">http://www.wrox.com/WileyCDA/</a>“</td><td>设置或返回完整的 URL。</td></tr><tr><td>protocol</td><td>“http”</td><td>设置或返回当前 URL 的协议。</td></tr><tr><td>pathname</td><td>“/WileyCDA/“</td><td>设置或返回当前 URL 的路径部分。</td></tr><tr><td>search</td><td>“?q=javascript”</td><td>设置或返回从问号 (?) 开始的 URL（查询部分）。</td></tr><tr><td>hash</td><td>“#content”</td><td>设置或返回从井号 (#) 开始的 URL（锚）。</td></tr><tr><td>host</td><td>“www.wrox.com:80”</td><td>设置或返回主机名和当前 URL 的端口号(如果有的话)。</td></tr><tr><td>hostname</td><td>“www.wrox.com”</td><td>设置或返回当前 URL 的主机名。</td></tr><tr><td>port</td><td>“8080”</td><td>设置或返回当前 URL 的端口号。</td></tr></table>

</blockquote>
<p>面试题：有一个页面，url为’<a href="http://qq.com?pet=cat&amp;age=2&amp;like=fish&#39;,设计一个函数将url附带的参数转换为对象返回" target="_blank" rel="external">http://qq.com?pet=cat&amp;age=2&amp;like=fish&#39;,设计一个函数将url附带的参数转换为对象返回</a></p>
<pre><code>function getParamObj(url){
    var startIndex =url.indexOf(&apos;?&apos;)+1;
    var subParam=url.substring(startIndex,url.length);
    var arrParam=subParam.split(&apos;&amp;&apos;);
    var objParam=new Object();//注意：初始化一个对象
    for(var i=0;i&lt;arrParam.length;i++){
        var arrSingle=arrParam[i].split(&apos;=&apos;);
        objParam[arrSingle[0]]=arrSingle[1];//注意：对象属性的赋值方法obj[key]=value
    }
    return objParam;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用createDocumentFragment()方法]]></title>
      <url>/2017/08/02/%E4%BD%BF%E7%94%A8createDocumentFragment()/</url>
      <content type="html"><![CDATA[<p>假如想创建十个段落，使用常规的方式可能会写出这样的代码：</p>
<pre><code>for(var i = 0 ; i &lt; 10; i ++) {
    var p = document.createElement(&quot;p&quot;);
    var oTxt = document.createTextNode(&quot;段落&quot; + i);
    p.appendChild(oTxt);
    document.body.appendChild(p);
}
</code></pre><p>当然，这段代码运行是没有问题，但是他调用了十次document.body.appendChild()，每次都要产生一次页面渲染。这时碎片就十分有用了：</p>
<pre><code>var oFragment = document.createDocumentFragment();

for(var i = 0 ; i &lt; 10; i ++) {
    var p = document.createElement(&quot;p&quot;);
    var oTxt = document.createTextNode(&quot;段落&quot; + i);
    p.appendChild(oTxt);
    oFragment.appendChild(p);&lt;br data-filtered=&quot;filtered&quot;&gt;}
1
document.body.appendChild(oFragment);
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM操作]]></title>
      <url>/2017/08/02/DOM%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>DOM是文档对象模型(Document Object Model)，是W3C出台的推荐标准。其赋予了JS操作节点的能力。当网页被加载时，浏览器就会创建页面的文档对象模型。</p>
<p>可以理解为：浏览器把拿到的html代码，<strong>结构化</strong>成一个浏览器<strong>能识别</strong>并且js<strong>可操作</strong>的模型。</p>
<p>DOM被构造为对象的<strong>树</strong>。</p>
<h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><h3 id="一、新增节点"><a href="#一、新增节点" class="headerlink" title="一、新增节点"></a>一、新增节点</h3><p>（1）createElement();——创建元素节点</p>
<p>（2）createTextNode();——创建文本节点</p>
<p>（3）createDocumentFragment();——创建一个虚拟DOM片段</p>
<pre><code>var oFragment = document.createDocumentFragment();

for(var i = 0 ; i &lt; 10; i ++) {
    var p = document.createElement(&quot;p&quot;);
    var oTxt = document.createTextNode(&quot;段落&quot; + i);
    p.appendChild(oTxt);
    oFragment.appendChild(p);&lt;br data-filtered=&quot;filtered&quot;&gt;
}

document.body.appendChild(oFragment);
</code></pre><h3 id="二、插入节点"><a href="#二、插入节点" class="headerlink" title="二、插入节点"></a>二、插入节点</h3><p>（1）appendChild(newNode);——插入新创建的节点；也可以将已有的节点移动位置</p>
<pre><code>//新增节点
var p=document.createElement(&quot;p&quot;);
p.innerHTML=&quot;new p&quot;;
var div1=document.getElementById(&quot;div1&quot;);
div1.appendChild(p);

//移动节点
var p4=document.getElementById(&quot;p4&quot;);
div1.appendChild(p4);
</code></pre><p>（2）insertBefore(newNode,existingNode);</p>
<pre><code>//移动某个列表项到另一个列表项：
var node=document.getElementById(&quot;myList2&quot;).lastChild;
var list=document.getElementById(&quot;myList1&quot;);
list.insertBefore(node,list.childNodes[0]);
</code></pre><h3 id="三、删除节点"><a href="#三、删除节点" class="headerlink" title="三、删除节点"></a>三、删除节点</h3><p>（1）removeChild();</p>
<pre><code>var div1=document.getElementById(&quot;div1&quot;);
var childNodes=div1.childNodes;//有五个，其中包括三个空的text
div1.removeChild(childNodes[1]);
</code></pre><h3 id="四、替换节点"><a href="#四、替换节点" class="headerlink" title="四、替换节点"></a>四、替换节点</h3><p>（1）replaceChild(newnode,oldnode);</p>
<pre><code>var textnode=document.createTextNode(&quot;Water&quot;);
var item=document.getElementById(&quot;myList&quot;).childNodes[0];
item.replaceChild(textnode,item.childNodes[0]);
</code></pre><h3 id="五、获取父节点"><a href="#五、获取父节点" class="headerlink" title="五、获取父节点"></a>五、获取父节点</h3><p>（1）node.parentNode;</p>
<pre><code>//获取父元素
var p4=document.getElementById(&quot;p4&quot;);
console.log(p4.parentNode);
</code></pre><h3 id="六、获取子节点"><a href="#六、获取子节点" class="headerlink" title="六、获取子节点"></a>六、获取子节点</h3><p><strong>节点的类型：nodeType</strong></p>
<pre><code>元素类型    节点类型
元素            1
属性            2
文本            3
注释            8
文档            9
</code></pre><p>（1）node.childNodes;</p>
<pre><code>for (var i = 0; i &lt; oList.childNodes.length; i++) {//oList是做的ul的对象。  
    //nodeType是节点的类型，利用nodeType来判断节点类型，再去控制子节点  
    if (oList.childNodes[i].nodeType == 1) {//查找到oList内的元素节点  
        console.log(oList.childNodes[i]);//在控制器日志中显示找到的元素节点  
    }  
} 
</code></pre><p>（2）node.children;</p>
<p>children也可以获取子节点，而且兼容各种浏览器,包括IE6-8</p>
<p>（3）node.firstChild和node.firstElementChild</p>
<p>查找第一个子节点。此存在浏览器兼容问题：firstChild是IE兼容，firstElementChild是非IE（6，7，8）兼容。</p>
<p>（4）node.lastChild和node.lastElementChild</p>
<p>查找最后一个子节点。此存在浏览器兼容问题：lastChild 是IE兼容，lastElementChild是非IE兼容。</p>
<p>（5）node.nextSbling;–&gt;查找下一个兄弟节点。</p>
<p>（6）node.previousSbling;–&gt;查找上一个兄弟节点。</p>
<h3 id="七、查找节点"><a href="#七、查找节点" class="headerlink" title="七、查找节点"></a>七、查找节点</h3><p>（1）document.getElementById();</p>
<p>（2）document.getElementsByTagName();</p>
<p>（3）document.getElementsByName();</p>
<p>（4）document.getElementsByClassName();</p>
<p>IE9以下的版本却不支持document.getElementsByClassName方法，<font color="red">有兼容性问题</font>，可使用原生JS模拟重新实现。</p>
<p><strong>解析</strong>：通过获取指定的标签，使用getElementsByTagName来获取标签内容，然后根据标签的className跟传进来的参数进行对比，如果相等就插入数组，最后返回数组。</p>
<pre><code>function getClassNames(classStr,tagName){  
      if (document.getElementsByClassName) {  
            return document.getElementsByClassName(classStr)  
      }else {  
            var nodes = document.getElementsByTagName(tagName),ret = [];           
            for(i = 0; i &lt; nodes.length; i++) {  
             if(hasClass(nodes[i],classStr)){  
                 ret.push(nodes[i])  
             }  
          }  
            return ret;  
      }  
}  
function hasClass(tagStr,classStr){  
     var arr=tagStr.className.split(/\s+/ );  //这个正则表达式是因为class可以有多个,判断是否包含  
     for (var i=0;i&lt;arr.length;i++){  
            if (arr[i]==classStr){  
                  return true ;  
            }  
     }  
     return false ;  
}  

//调用
var  divs = getClassNames(&apos;tabs_div&apos; , &apos;div&apos;);  
</code></pre><p>（5）document.querySelectorAll();</p>
<pre><code>//综合例子    
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;DOM节点获取&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot; class=&quot;class-div1&quot;&gt;
        &lt;p id=&quot;p1&quot; data-name=&quot;p1-data-name&quot;&gt;this is p1&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;this is p2&lt;/p&gt;
    &lt;/div&gt;
    &lt;div id=&quot;div2&quot;  name=&quot;div2&quot;&gt;
        &lt;p id=&quot;p3&quot;&gt;this is p3&lt;/p&gt;
        &lt;p id=&quot;p4&quot;&gt;this is p4&lt;/p&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var div1=document.getElementById(&quot;div1&quot;);
        var divList=document.getElementsByTagName(&quot;div&quot;);
        var div2=document.getElementsByName(&quot;div2&quot;)[0];
        console.log(div2);
        console.log(divList.length);
        console.log(divList[0]);
        var pList=document.getElementsByClassName(&quot;class-div1&quot;);
        console.log(pList);
        var pListAll=document.querySelectorAll(&quot;p&quot;);
        console.log(pListAll);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="DOM节点的Attribute和property"><a href="#DOM节点的Attribute和property" class="headerlink" title="DOM节点的Attribute和property"></a>DOM节点的Attribute和property</h2><p>区别：property:只是一个JS对象的属性的获取、修改<br><br>attribute:是对html标签属性的获取修改</p>
<pre><code>//property
var div1=document.getElementById(&quot;div1&quot;);
console.log(div1.className);
div1.className=&quot;abc&quot;;
console.log(div1.className);

//attribute
var p1=document.getElementById(&quot;p1&quot;);
console.log(p1.getAttribute(&quot;data-name&quot;));
p1.setAttribute(&quot;data-name&quot;,&quot;aaa&quot;);
console.log(p1.getAttribute(&quot;data-name&quot;));
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写一个能遍历对象和数组的forEach函数]]></title>
      <url>/2017/08/02/%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84forEach%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><strong>解析</strong>：数组API中有forEach(function(item,index){})方法，但是需要注意参数的顺序；而对象是通过for(…in..)方法实现遍历。</p>
<p><strong>小贴士</strong>：在编码实现的过程中，可以先考虑如何去调用，然后再暗要求实现函数定义。</p>
<pre><code>function forEach(obj,fn){
    if(obj instanceof Array){
        obj.forEach(function(item,index){
            fn(index,item);
        });
    }
    else{
        for(var key in obj){
            if(obj.hasOwnProperty(key)){
                fn(key,obj[key]);
            }
        }
    }
}

//调用
var arr=[1,2,3,4];
forEach(arr,function(index,item){
    console.log(index,item);
});

var obj={
    a:100,
    b:200,
    c:300
};
forEach(obj,function(key,value){
    console.log(key,value);
});
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> forEach </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写一个生成num个在[min-max]之间的随机整数函数]]></title>
      <url>/2017/08/02/%E5%86%99%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90num%E4%B8%AA%E5%9C%A8%5Bmin-max%5D%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B4%E6%95%B0%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><strong>解析</strong>：</p>
<ul>
<li>Math.random()方法返回大于等于0小于1的一个随机数；</li>
<li>Math.ceil()方法执行向上舍入，即大于等于当前数；</li>
<li>Math.floor()方法执行向下舍入，即小于等于当前数；</li>
<li><p>Math.round()方法标准舍入（四舍五入）</p>
<pre><code>function setArr(num,min,max){
    if(max&gt;min){
        var range=max-min;
        var arr=[];
        for(var i=0;i&lt;num;i++){
            var value=Math.floor(Math.random()*range)+min;
            arr.push(value);
        }
        return arr;
    }    
}

setArr(22,0,15);
</code></pre></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> forEach </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[异步和单线程]]></title>
      <url>/2017/08/02/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-什么是异步，和同步有什么异同"><a href="#1-什么是异步，和同步有什么异同" class="headerlink" title="1.什么是异步，和同步有什么异同"></a>1.什么是异步，和同步有什么异同</h3><p>同步会阻塞代码的执行，而异步不会。 简单的例子，alert()是同步，setTimeout()是异步。</p>
<pre><code>1.   console.log(100);
2.   setTimeout(fucntion(){
3.       console.log(200);
4.   },1000);
5.   console.log(300);
6.   
7.    //结果
8.    100
9.    300
10.    200
</code></pre><p><br></p>
<pre><code>11.    console.log(100);
12.    alert(200);//有阻塞，卡顿
13.    console.log(300);
</code></pre><p><strong>JavaScript引擎解析是一个单线程的过程</strong>,浏览器无论在任何时候有且只有一个线程在运行Javascript程序，如果没有异步的话，单线程会出现“卡顿”。上边例子体现了JS中单线程和异步的关系（执行过程如下）：</p>
<p>（1）执行第1行,打印100；</p>
<p>（2）执行第2行setTimeout后，传入setTimeout的函数会被<strong>暂存</strong>起来，<strong>不会立即执行</strong>（<font color="red">单线程的特点：不会同时执行两件事</font>）</p>
<p>（3）执行第5行，打印300；</p>
<p>（4）待所有程序执行完，处于空闲状态时，会立即查看又有没有暂存起来要执行的；</p>
<p>（5）发现暂存起来的setTimeout中的函数，等待1000ms，开始执行，打印出200.</p>
<h3 id="2-前端使用异步的场景"><a href="#2-前端使用异步的场景" class="headerlink" title="2.前端使用异步的场景"></a>2.前端使用异步的场景</h3><p>在实际开发应用中，需要等待的地方，就会用到异步。</p>
<ol>
<li><p>定时任务：setTimeout()、setInterval()</p>
<pre><code>console.log(100);
setTimeout(function(){
    console.log(200);
},1000)
console.log(300);             
</code></pre></li>
<li><p>网络请求：ajax请求，动态<img>加载</p>
<pre><code>//使用异步的场景——ajax请求（此例子需要完善）
 console.log(&quot;start&quot;);
 $.get(&apos;test-test.json&apos;,function(data){
     console.log(data);
 })
 console.log(&quot;end&quot;);

//网络请求图片加载
 console.log(&quot;start&quot;);
 var img=document.createElement(&apos;img&apos;);
 img.onload=function(){
     console.log(&apos;loaded&apos;);
 }
 img.src=&apos;http://pic6.huitu.com/res/20130116/84481_20130116142820494200_1.jpg&apos;;        
 console.log(&quot;end&quot;)
</code></pre></li>
<li><p>事件绑定</p>
<pre><code>//事件绑定
console.log(&quot;start&quot;);
var btn1=document.getElementById(&quot;btn1&quot;);
btn1.addEventListener(&apos;click&apos;,function(){
    console.log(&quot;clicked&quot;);
});
console.log(&quot;end&quot;);
</code></pre></li>
</ol>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript_this的几种使用场景]]></title>
      <url>/2017/08/02/this%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<p>this在定义的时候是确定不了的，只有其在函数执行的时候才能确认值。一般而言，在JavaScript中this指向函数执行时的当前对象，谁调用的就指向谁。</p>
<ol>
<li><p>作为构造函数调用，this 指代new 出的对象</p>
<pre><code>function Foo(name){
    //this={};
    this.name=name;
    //return this;
}
var f=new Foo(&apos;zhangsan&apos;);
</code></pre></li>
<li><p>作为对象属性方法调用，this 指代上级对象</p>
<pre><code>var obj={
    name:&apos;A&apos;,
    printName:function(){
        name:&apos;B&apos;;
        console.log(this.name);
    }
}

obj.printName();
</code></pre></li>
<li><p>作为普通对象函数执行，this指代全局对象</p>
<pre><code>function fn(){
    console.log(this);//this===window
}

fn();
</code></pre></li>
<li><p>在call,apply,bind中使用，此方法的第一个参数为改变后调用这个函数的对象，this指代第一个参数</p>
<pre><code>function fn1(name){
    alert(name);
    console.log(this);
}

fn1.call({x:100},&quot;zhangsan&quot;);//这时fn1中的this就是{x:100}

fn1.apply({x:100},[&quot;zhangsan&quot;,20]);//这时fn1中的this就是{x:100}

//bind使用时需要是函数表达式的形式
var fn3 = function (name,age){
    alert(name);
    console.log(this);
}.bind({y:200})//这时fn3中的this是{y:200}
fn3(&apos;zhangsan&apos;,20);
</code></pre></li>
</ol>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> this </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[作用域和闭包]]></title>
      <url>/2017/08/02/javascript_%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
<p>闭包的使用场景：</p>
<ul>
<li>函数作为返回值</li>
<li>函数作为参数传递</li>
</ul>
<h2 id="javascript中变量的作用域"><a href="#javascript中变量的作用域" class="headerlink" title="javascript中变量的作用域"></a>javascript中变量的作用域</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。JS中无块级作用域，只有函数作用域和全局作用域。</p>
<pre><code>if(true){
    var color=&quot;blue&quot;;
}

console.log(color);//&quot;blue&quot;-&gt;因为对JavaScript来说，没有块级作用域，所以不会报错
</code></pre><p>1.执行上下文 </p>
<p>全局作用域：在一段&lt;script&gt;中，在执行之前回把函数的声明和变量的声明提到最前面。</p>
<pre><code>console(a);//undefined
var a=10;
</code></pre><p>函数作用域：在函数之前之前，函数中也会将变量和函数的声明提到函数中的前面。</p>
<font color="red">注：函数声明和函数表达式不同。</font>

<pre><code>fn();//不会报错
function fn(){
    //声明
}
</code></pre><p><br></p>
<pre><code>fu()；//会报错
var fn=function(){
    //表达式
}；
</code></pre><p>区别：函数声明在JS解析时进行函数<strong>提升</strong>，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JS运行时确定，并且在表达式赋值完成后，该函数才能调用。</p>
<p>2.作用域链</p>
<p>​ <strong>作用域链</strong>，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。<br><br>体现在自由变量（即在当前作用域中没有定义的变量）的值要去其父作用域中找。<strong>父作用域</strong>是指定义它的作用域，而不是执行它的作用域。</p>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><p>实际开发过程中，闭包用来封装变量，收敛权限。</p>
<p>（1）使用闭包可以在javascript中模仿块级作用域。</p>
<p>创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。</p>
<p>结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。</p>
<pre><code>//创建10个&lt;a&gt;标签的点击的时候弹出对应的序号
var i;
for(i=0;i&lt;10;i++){//自执行函数
    (function(i){
        //i函数作用域
        var a=document.createElement(&apos;a&apos;);
        a.innerHTML=i+&quot;&lt;br&gt;&quot;;
        a.addEventListener(&apos;click&apos;,function(e){
            e.preventDefault();//阻止a标签的默认事件
            alert(i);//i是自由变量，需要去父作用域获取值，此处无块级作用域，所以i是全局作用域，最后弹出无论点击哪个都是10
        });
        document.body.appendChild(a);
    })(i)
}

//自执行函数：就是不用调用，只要定义完成，立即执行的函数
</code></pre><p>(2) 用于在对象中创建私有变量。</p>
<ul>
<li><p>即使JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量</p>
</li>
<li><p>有权访问私有变量的公有方法叫做特权方法</p>
</li>
</ul>
<p>如下所示，在isFirstLoad 函数外面，根本不能修改掉_list 的值</p>
<pre><code>function isFirstLoad(){
    var _list=[]; 
    return function(id){
        if(_list.indexOf(id)&gt;=0){
            return false;    
        }
        else{
            _list.push(id);
            return true;
        }
    }
}

var firstLoad=isFirstLoad();
firstLoad(10);//true
firstLoad(10);//false
firstLoad(20);//true
firstLoad(20);//false
</code></pre><h2 id="闭包中的问题"><a href="#闭包中的问题" class="headerlink" title="闭包中的问题"></a>闭包中的问题</h2><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 </p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[new一个对象的过程]]></title>
      <url>/2017/07/31/js_new%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>(1) 创建一个新对象</p>
<p>(2) 将构造函数的作用域赋给新对象，（因此this就指向了这个对象）</p>
<p>(3) 执行代码，即对this赋值</p>
<p>(4) 返回this</p>
<pre><code>//例子
function Foo(name,age){
    this.name=name;                    //(3)
    this.age=age;                    //(3)
    this.class=&quot;class-1&quot;;            //(3)
    //return this;        //默认有这一行(4)
}

var f1 = new Foo(&quot;zhangsan&quot;,23);    //(1)(2)
</code></pre><h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><h3 id="对象字面量的方式"><a href="#对象字面量的方式" class="headerlink" title="对象字面量的方式"></a>对象字面量的方式</h3><pre><code>var person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};
</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><pre><code>//工厂模式用函数来封装以特定接口创建对象的细节
function createPerson(name,age,job){
    var o=new Object();
    o.name=name;
    o.age=age;
    o.job=job;

    o.sayHi=function(){
        console.log(this.name);
    };
    return o;
}

var person1=createPerson(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);
person1.sayHi();//Nicholas
var person2=createPerson(&quot;Grey&quot;,27,&quot;Doctor&quot;);
person2.sayHi();//Grey
</code></pre><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>如下所示，在这个例子中，Person()函数取代了createPerson()函数。我们注意到，它俩的不同之处：<br><br>（1）没有显示地创建对象<br><br>（2）直接将属性和方法赋给了this对象<br><br>（3）没有return语句</p>
<pre><code>function Person(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;
    this.sayName=function(){
        console.log(this.name);
    };
}

var person1=new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);
var person2=new Person(&quot;Grey&quot;,27,&quot;Doctor&quot;);
</code></pre><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><pre><code>//利用函数的原型属性（prototype属性）
function Person(){

}
Person.prototype.name=&quot;Nicholas&quot;;
Person.prototype.age=29;
Person.prototype.job=&quot;SoftWare Engineer&quot;;
Person.prototype.sayName=function(){
    console.log(this.name);
}

var person1=new Person();
person1.sayName();//Nicholas

var person2=new Person();
person2.sayName();//Nicholas

console.log(person1.sayName==person2.sayName);//true

//可以利用isPrototypeOf()来判断对象之间是否存在原型系统与实例间的关系
console.log(Person.prototype.isPrototypeOf(person1));//true
</code></pre><h3 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h3><pre><code>//组合使用构造函数模式与原型模式，
function Person(name,age,job){
    this.name=name;
    this.age=age;
    this,job=job;
    this.friends=[&quot;Shelby&quot;,&quot;Court&quot;];
}

Person.prototype={
    constructor:Person,
    sayName:function(){
        console.log(this.name);
    }
}

var person1=new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);
var person2=new Person(&quot;Grey&quot;,21,&quot;Doctor&quot;);

person1.friends.push(&quot;Van&quot;);
console.log(person1.friends);//[ &apos;Shelby&apos;, &apos;Court&apos;, &apos;Van&apos; ]
console.log(person2.friends);//[ &apos;Shelby&apos;, &apos;Court&apos; ]

console.log(person1.friends===person2.friends);//false
console.log(person1.sayName===person2.sayName);//true
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> new，面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原型和原型链]]></title>
      <url>/2017/07/31/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<h3 id="原型规则"><a href="#原型规则" class="headerlink" title="原型规则"></a>原型规则</h3><blockquote>
<ol>
<li>所有的引用类型变量（对象，数组、函数），都有构造函数</li>
<li>所有引用类型变量（对象，数组、函数），都具有对象特性，即可自由扩展属性。</li>
<li>所有引用类型变量（对象，数组、函数），都有一个隐式原型属性（__proto__）,属性值也是一个普通的对象。</li>
<li><strong>所有函数</strong>都有一个显示原型属性（prototype)，属性值也是一个普通的对象。</li>
<li>当试图得到一个引用类型的某个属性是，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找。</li>
</ol>
</blockquote>
<h4 id="访问一个对象的属性过程体现了原型链规则"><a href="#访问一个对象的属性过程体现了原型链规则" class="headerlink" title="访问一个对象的属性过程体现了原型链规则"></a>访问一个对象的属性过程体现了原型链规则</h4><p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。<br></p>
<p>​ 在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空——执行上下文环境。<br></p>
<p>​ <strong>作用域链</strong>，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。<br></p>
<p>​ 每一个对象都会在内部链接到另一个对象(该对象的原型对象)，该对象有一个原型prototype，当访问对象的属性或是方法的时候，不仅仅会在原对象上查找，还会顺着原型链在原型对象的原型链上查找，直到查到null(所有原型链的顶层)为止。原型是JavaScript实现继承的基础，new关键字做的主要的事情就是将实例对象的__proto__属性指向原型对象的prototype。</p>
<h3 id="一个原型链继承的例子"><a href="#一个原型链继承的例子" class="headerlink" title="一个原型链继承的例子"></a>一个原型链继承的例子</h3><pre><code>function Elem(id){
    this.elem=document.getElementById(id);
}

Elme.prototype.html=function(var){
    var elem=this.elem;
    if(var){
        elem.innerHTML=val;
        return this;
    }else{
        return elem.innerHTML;
    }
}
Elem.prototype.on=function(type,fn){
    var elem=this.elem;
    elem.addEventListener(type,fn);
}
//实例
var div1=new Elem(&quot;div1&quot;);
div1.html(&quot;&lt;p&gt;hello&lt;/p&gt;&quot;);
div1.on(&apos;click&apos;,function(){
    alert(&apos;clicked&apos;);
});
</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>因 typeof 只能判断值类型数据的变量类型，但如果变量的值是一个对象或者null，则判断不了。为此提供了 instanceof 操作符，其语法如下所示</p>
<pre><code>result = variable instanceof constructor
//例如：
alert(person instanceof Object);
alert(colors instanceof Array);
alert(pattern instanceof RegExp);
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js基础知识，面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript数据类型]]></title>
      <url>/2017/07/31/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>Javascript按存储方式区分变量类型：值类型（也称基本数据类型）和引用数据类型。</p>
<h3 id="1-基本数据（值）类型"><a href="#1-基本数据（值）类型" class="headerlink" title="1.基本数据（值）类型"></a>1.基本数据（值）类型</h3><p>字符串型（String）；数值型（Number）;布尔型（Boolean）;未定义（undefined）；Null类型</p>
<h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h3><p>对象（Object）类型；数组类型（Array）；函数类型（function）</p>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><p>基本数据类型的变量存放的是基本类型数据的实际值；而引用数据类型的变量保存对它的引用，即指针。<br><br>引用数据类型好几个变量共用一个内存块，赋值一旦被修改，互相会有影响。</p>
<h3 id="4-需注意"><a href="#4-需注意" class="headerlink" title="4.需注意"></a>4.需注意</h3><p>(1) <strong>typeof</strong>只能区分值类型的详细类型，如果这个值是引用数据类型或者null，则区分不出来</p>
<pre><code>typeof 95            //&quot;number&quot;
typeof &apos;aa&apos;            //&quot;string&quot;
typeof true            //&quot;boolean&quot;
typeof undefined    //&quot;undefined&quot;
typeof null            //&quot;object&quot;

var o= new Object();
typeof o            //&quot;object&quot;
</code></pre><p>(2) <strong>null==undefined会返回true,但null===undefined会返回false。</strong>那么编码过程中，什么时候用“==”，什么时候用“===”呢？</p>
<p>a.对象的属性是否存在    </p>
<pre><code>if(obj.a==null){
    //这里相当于obj.a===null||obj.a==undefined，简写形式
    //这是jQuery源码中的推荐写法
}
</code></pre><p>b.函数的参数a是否存在</p>
<pre><code>function(a,b){
    if(a==null){
        ...
    }
}
</code></pre><font color="red">其他情况都用“===”。</font>

<p>(3)怎么判断一个变量a在if语句中是true还是false?</p>
<pre><code>!!(a);
</code></pre><font color="red">注：</font> 0，NaN，’’，null，false，undefined–&gt;会转换为false<br><br>(4)JS中的内置函数：Object，Array，Boolean，Number，String，Function，Date，RegExp，Error…<br><font color="red">Math是内置对象，不是函数。</font>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> js数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2014/03/16/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
