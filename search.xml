<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[JS哪些操作会造成内存泄漏]]></title>
      <url>/2017/08/03/JS%E7%9A%84%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<ul>
<li><p>意外的全局变量一起内存泄漏（可以加上‘use strict’启用严格模式）</p>
</li>
<li><p>闭包引起的内存泄漏</p>
</li>
<li><p>没有清理的DOM元素引用</p>
</li>
<li><p>被遗忘的定时器或者回调</p>
</li>
<li><p>子元素存在引用引起的内存泄漏</p>
</li>
</ul>
<p>参考资料：<a href="http://www.jianshu.com/p/763ba9562864" title="http://www.jianshu.com/p/763ba9562864" target="_blank" rel="external">http://www.jianshu.com/p/763ba9562864</a></p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[性能优化]]></title>
      <url>/2017/08/03/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="前端优化的原则"><a href="#前端优化的原则" class="headerlink" title="前端优化的原则"></a>前端优化的原则</h1><ul>
<li>多使用内存、缓存或者其他方法</li>
<li>减少CPU计算，减少网络请求<h1 id="从哪里入手"><a href="#从哪里入手" class="headerlink" title="从哪里入手"></a>从哪里入手</h1></li>
</ul>
<ol>
<li>加载页面和静态资源</li>
<li>页面渲染<h2 id="1-加载页面和静态资源"><a href="#1-加载页面和静态资源" class="headerlink" title="1.加载页面和静态资源"></a>1.加载页面和静态资源</h2>（1）静态资源的压缩合并（减少资源请求）</li>
</ol>
<p>（2）合理利用静态资源缓存（减少请求）–&gt;通过连接名称控制缓存；只有内容改变时，链接名称才会改变</p>
<p>（3）使用CDN让资源加载更快（不同地域的资源优化）</p>
<p>（4）使用SSR(服务器端渲染)后端渲染，数据直接输入HTML中（而不是我们用的，现价在HTML,再用Ajax请求，把数据拿过来）</p>
<h2 id="2-渲染优化"><a href="#2-渲染优化" class="headerlink" title="2.渲染优化"></a>2.渲染优化</h2><p>（1）CSS放前面，JS放后面</p>
<p>（2）懒加载（图片懒加载，下拉加载更多）</p>
<pre><code>&lt;!--先给页面img标签放一个比较小，或者缓存中有的图片--&gt;
&lt;img id=&quot;img1&quot; src=&quot;previous.png&quot; data-realsrc=&quot;abc.png&quot;/&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    var img1=document.getElementById(&quot;img1&quot;);//当真实用到时，再加载真正的图片
    img1.src=img1.getAttribute(&quot;data-realsrc&quot;);
&lt;/script&gt;
</code></pre><p>（3）减少DOM查询，对DOM查询做缓存</p>
<p>循环时，将DOM查询一次查出，赋值给变量（缓存）</p>
<p>（4）减少DOM操作，多个操作尽量合并在一起执行</p>
<p>如：使用创建一个片段：createDocumentFragment(),它里边的appendChild()不触发DOM操作</p>
<p>（5）事件节流</p>
<p>如：快速操作的时候，不触发事件；停下来的时候，再触发<br>例：</p>
<pre><code>var textarea=document.getElementById(&quot;textarea&quot;);
var timeoutId;
textarea.addEventListener(&apos;keyup&apos;,function(){
    if(timeoutId){
        clearTimeout(timeoutId)
    }
    timeoutId=setTimeout(function(){//事件节流：体现在当时间间隔超过100ms以上未触发keyups时，进行事件操作
        //触发change事件
    }，100)
});
</code></pre><p>（6）尽早执行操作（如：DOMContentLoaded）</p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[页面渲染过程]]></title>
      <url>/2017/08/03/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h1><h2 id="1-加载资源的形式："><a href="#1-加载资源的形式：" class="headerlink" title="1.加载资源的形式："></a>1.加载资源的形式：</h2><ul>
<li><p>输入url（或跳转页面）加载html——&gt;(<strong>加载页面</strong>)</p>
</li>
<li><p>加载html中的<strong>静态资源</strong>——&gt;(加载js,css,图片，视频)</p>
<h2 id="2-加载一个资源的过程（从输入url到获取html的过程）"><a href="#2-加载一个资源的过程（从输入url到获取html的过程）" class="headerlink" title="2.加载一个资源的过程（从输入url到获取html的过程）"></a>2.加载一个资源的过程（从输入url到获取html的过程）</h2><p>（1）浏览器根据DNS服务器得到域名的IP地址</p>
</li>
</ul>
<p>（2）向这个IP对应的机器发送http（https）请求</p>
<p>（3）服务器收到，处理并返回http(…)请求</p>
<p>（4）浏览器得到返回内容</p>
<h2 id="3-浏览器渲染页面的过程"><a href="#3-浏览器渲染页面的过程" class="headerlink" title="3.浏览器渲染页面的过程"></a>3.浏览器渲染页面的过程</h2><p>（1）根据HTML结构生成DOM树</p>
<p>（2）根据CSS生成CSSOM（结构化的CSS）</p>
<p>（3）将DOM和CSSOM整合形成RenderTree(渲染树)</p>
<p>（4）浏览器根据RenderTree开始渲染和展示</p>
<p>（5）遇到&lt;script&gt;时，会执行并阻塞渲染（<font color="red">为什么会阻塞，因为&lt;script&gt;会操作改变DOM树，会有冲突，所以会有“阻塞”</font>）</p>
<p>注：图片是异步加载的，不会阻塞页面渲染</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><h3 id="1-为什么要把CSS放在-lt-head-gt-中"><a href="#1-为什么要把CSS放在-lt-head-gt-中" class="headerlink" title="1.为什么要把CSS放在&lt;head&gt;中"></a>1.为什么要把CSS放在&lt;head&gt;中</h3><ul>
<li>用户体验差，渲染两次，有卡顿现象</li>
<li>性能差，一次就可以渲染出来，放后边就要渲染多次<h3 id="2-为什么要把js放在最后面"><a href="#2-为什么要把js放在最后面" class="headerlink" title="2.为什么要把js放在最后面"></a>2.为什么要把js放在最后面</h3></li>
<li>不会阻塞HTML结构渲染，使页面更快出来</li>
<li><p>放在上面时，不能拿到页面所有的标签</p>
<h3 id="3-window-onload和DOMContentLoaded区别"><a href="#3-window-onload和DOMContentLoaded区别" class="headerlink" title="3.window.onload和DOMContentLoaded区别"></a>3.window.onload和DOMContentLoaded区别</h3><p>  window.addEventListener(‘load’,function(){</p>
<pre><code>//页面的全部资源加载完才执行，包括图片，视频
</code></pre><p>  });<br>  window.addEventListener(‘DOMContentLoaded’,function(){</p>
<pre><code>//DOM渲染完即刻执行，此时图片，视频资源可能还没加载完
</code></pre><p>  });</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[上线回滚流程要点]]></title>
      <url>/2017/08/03/%E4%B8%8A%E7%BA%BF%E5%92%8C%E5%9B%9E%E6%BB%9A/</url>
      <content type="html"><![CDATA[<h2 id="上线流程要点"><a href="#上线流程要点" class="headerlink" title="上线流程要点"></a>上线流程要点</h2><blockquote>
<ul>
<li>将测试完成的代码提交到git版本库的master分支</li>
<li>将当前服务器的代码全部打包并记录版本号，备份（如，v1.0）</li>
<li>将master分支的代码提交覆盖到线上服务器，生成新版本号（如，v1.1）</li>
</ul>
</blockquote>
<h2 id="回滚流程要点"><a href="#回滚流程要点" class="headerlink" title="回滚流程要点"></a>回滚流程要点</h2><blockquote>
<ul>
<li>将当前服务器的代码打包并记录版本号，备份（如，v1.1）</li>
<li>将备份的上一个版本（如v1.0）号解压，覆盖到线上服务器，并生成新版本号（如，v1.2）</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[模块化]]></title>
      <url>/2017/08/03/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>首先，我们了解，不模块化的话：</p>
<ul>
<li>这些代码中的函数必须使用全局变量，才能暴露给对方，这会造成<strong>全局变量污染</strong>。</li>
<li><p>开发过程中，需要知道各js文件间的依赖关系（甚至是底层js文件）。<br>因此，模块化开发可以通过高度抽象出很多东西的相同点，进行写一个模块，简化代码结构，提升代码的效率，其实就是<strong>代码复用</strong>。</p>
<h1 id="AMD（异步模块定义规范）"><a href="#AMD（异步模块定义规范）" class="headerlink" title="AMD（异步模块定义规范）"></a>AMD（异步模块定义规范）</h1><p>是 RequireJS 在推广过程中对模块定义的规范化产出。AMD<strong>异步加载</strong>模块，不用就不加载，使加载变得比较合理，响应加快。（<font color="red">调试小技巧：F12-&gt;“network”可看页面加载内容</font>）</p>
<p>  require.js(工具)：全局define函数</p>
<pre><code>全局require函数
依赖的js文件 会自动异步加载
</code></pre><h3 id="主要解决了两个问题："><a href="#主要解决了两个问题：" class="headerlink" title="主要解决了两个问题："></a>主要解决了两个问题：</h3></li>
</ul>
<ol>
<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>
<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><strong>本身自己不会异步加载JS，而是同步一次性加载出来</strong>。CommonJs 是服务器端模块的规范，Node.js采用了这个规范。 </li>
</ol>
<p>根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象（模块只有一个出口：module.exports对象）。 </p>
<h1 id="AMD和CommonJS不同"><a href="#AMD和CommonJS不同" class="headerlink" title="AMD和CommonJS不同"></a>AMD和CommonJS不同</h1><ul>
<li>AMD异步的，CommonJS同步的</li>
<li>使用场景：需要异步加载JS，使用AMD;使用了npm之后，建议使用CommonJS<a id="more"></a>
<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1>CMD是SeaJS 在推广过程中对模块定义的规范化产出。cmd是用在浏览器端的，<strong>异步的</strong>。</li>
</ul>
<p>CMD和AMD的区别有以下几点：amd先提出，cmd是根据commonjs和amd基础上提出的。 </p>
<p>1.对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不通过）。 </p>
<p>2.CMD推崇依赖就近，AMD推崇依赖前置。 </p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 模块化开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[本地存储]]></title>
      <url>/2017/08/03/%E5%AD%98%E5%82%A8cookie%E3%80%81sessionStorage%E5%92%8ClocalStorage/</url>
      <content type="html"><![CDATA[<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>cookie本身用于客户端和服务器端的通信。但是它有本地存储的功能呢个，于是就被借用了。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code>document.cookie=&apos;属性名=属性值&apos;    存储
document.cookie                  获取(获取所有的)
</code></pre><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>存储量太小，只有4KB</li>
<li>所有http请求都带着，会影响获取资源的效率</li>
<li>API简单，需要封装才能用，<code>document.cookie=...</code>使用起来比较麻烦<h1 id="localStorage-和-sessionStorage"><a href="#localStorage-和-sessionStorage" class="headerlink" title="localStorage 和 sessionStorage"></a>localStorage 和 sessionStorage</h1></li>
<li>HTML5专门为存储而设计，最大容量5M；</li>
<li><p>API简单易用：</p>
<pre><code>设置增加:localStorage.setItem(&apos;属性名&apos;,&apos;属性值&apos;)
获取指定:localStorage.getItem(&apos;属性名&apos;)

设置增加:sessionStorage.setItem(&apos;属性名&apos;,&apos;属性值&apos;)
获取指定:sessionStorage.getItem(&apos;属性名&apos;)
</code></pre><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>sessionStorage 和 localStorage 就一个不同的地方， <strong>sessionStorage数据</strong>的存储仅特定于某个会话中，也就是说数据<strong>只保持到浏览器关闭，</strong>当浏览器关闭后重新打开这个页面时， 之前的存储已经被清除。而 <strong>localStorage 是一个持久化的存储，它并不局限于会话</strong>。</p>
</li>
</ol>
<p>注：在ios safari隐藏模式下，localStorage.getItem会报错，建议统一使用try-catch封装。</p>
<h1 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h1><ul>
<li>容量：cookie:4KB<ul>
<li>sessionStorage和localStorage：5M    </li>
</ul>
</li>
<li>是否会携带到http请求中：cookie会，因其本身用于客户端和服务器通信<ul>
<li>sessionStorage和localStorage：不会，只用于存储</li>
</ul>
</li>
<li>API易用性：cookie:<code>document.cookie</code>需封装才能使用<ul>
<li>sessionStorage和localStorage：<code>.setItem(key,value); ``.getItem(key);</code></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 本地存储 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跨域]]></title>
      <url>/2017/08/03/jsonp%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>跨域，指的是突破同源策略的限制，本源的客户端脚本访问其他源的数据。那么什么是同源呢，这里解释下，同源即同协议&amp;&amp;同域名&amp;&amp;同端口。</p>
<p>#JSONP实现跨域 #<br>JSONP由两部分构成：回调函数和数据。回调函数,是当响应到来时，应该在页面中调用的函数<br>。数据，是传入回调函数中的JSON数据。</p>
<pre><code>function handleResponse(response){
    alert(&quot;You&apos;re at IP address &quot;+response.ip+&quot;, which is in &quot;+response.city+&quot;, &quot;+response.region_name);
}

var script=document.createElement(&quot;script&quot;);
script.src=&quot;http://freegeoip.net/json/?callback=handleResponse&quot;;
document.body.insertBefore(script,document.body.firstChild);
</code></pre><p>优缺点：</p>
<ol>
<li>安全问题(请求代码中可能存在安全隐患)</li>
<li>要确定jsonp请求是否失败并不容易</li>
</ol>
<h1 id="ajax和jsonp实现跨域的区别"><a href="#ajax和jsonp实现跨域的区别" class="headerlink" title="ajax和jsonp实现跨域的区别"></a>ajax和jsonp实现跨域的区别</h1><p>（1） ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；<br><br>（2）但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，使用XHR(XDR)对象并在open()方法中传入绝对URL；而jsonp的核心则是通过动态&lt;script&gt;元素来使用的，使用时可以为src属性指定一个跨域URL。</p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> jsonp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ajax和跨域问题]]></title>
      <url>/2017/08/03/ajax%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML）。</p>
<p>Ajax 的核心是 JavaScript 对象 <strong>XMLHttpRequest</strong>。该对象在 Internet Explorer 5 中首次引入，它是一种支持异步请求的技术。简而言之，XMLHttpRequest使您可以使用 JavaScript 向服务器提出请求并处理响应，而不阻塞用户。</p>
<h3 id="使用Ajax-XMLHttpRequest对象的过程"><a href="#使用Ajax-XMLHttpRequest对象的过程" class="headerlink" title="使用Ajax XMLHttpRequest对象的过程"></a>使用Ajax XMLHttpRequest对象的过程</h3><p>（1）创建XMLHttpRequest对象（注意兼容IE7之前的版本：ActiveXObject）</p>
<pre><code>function createXHR(){
    if(typeof XMLHttpRequest!=&quot;undefined&quot;){
        return new XMLHttpRequest();
    }else if(typeof ActiveXObject!=&quot;undefined&quot;){
        if(typeof arguments.callee.activeXString!=&quot;string&quot;){
            var versions=[&quot;MSXML2.XMLHttp.6.0&quot;,&quot;MSXML2.XMLHttp.3.0&quot;,&quot;MSXML2.XMLHttp&quot;];
            var i,len;
            for(i=0,len=versions.length;i&lt;len;i++){
                try{
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString=versions[i];
                    break;
                }catch(ex){
                    //跳过
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    }else{
        throw new Error(&quot;No XHR object available.&quot;);
    }
}

var xhr=createXHR();
</code></pre><p>（2）调用 open() 方法，传递三个参数：</p>
<ul>
<li>要发送的请求类型（ get , post 等）</li>
<li>请求的 url</li>
<li>是否异步发送请求</li>
</ul>
<p>（3）要发送特定的请求，必需像下面这样调用 send() 方法</p>
<pre><code>xhr.open(&quot;get&quot;,&quot;.request.php&quot;,false);//false表示这次的请求是同步的
xhr.send(null);
</code></pre><p>（4）在接到响应以后，第一步是检查status属性，以确定响应已成功返回，然后对响应内容进行处理</p>
<pre><code>if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status==304){
    alert(xhr.responseText);
}else{
    alert(&quot;Response was unsuccessfull:&quot;+xhr.status);
}
</code></pre><p>注：<strong>ajax发送异步请求时</strong>，检测 XHR 对象的 readyState 属性。只要 readyState 属性的值由一个值变为另一个值，都会触发一次 readystatechange 事件。</p>
<p>可以利用这个事件来检测每次状态变化后的 readyState 的值，通常，我们只对 readyState 值为 4 的阶段感兴趣，因为这时所有的数据都已经就绪。不过，必须在调用 open() 之前指定 onreadyState 事件处理程序才能确保跨浏览器兼容性。例子如下：</p>
<pre><code>var xhr=createXHR();
xhr.onreadyStateChange=function(){
    if(xhr.readyState==4){
        if((xhr.status&gt;=200&amp;&amp;shr.status&lt;300)||xhr.status==304){
            alert(xhr.responseText);
        }else{
            alert(&quot;Response was unsuccessfull:&quot;+xhr.status);
        }
    }
};
xhr.open(&quot;get&quot;,&quot;example.txt&quot;,true);
xhr.send(null);
</code></pre><h1 id="跨浏览器的CORS"><a href="#跨浏览器的CORS" class="headerlink" title="跨浏览器的CORS"></a>跨浏览器的CORS</h1><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8中引入了XDR（XDomainRequest对象）类型，使用方法与XHR对象相似。但open()方法只接受两个参数：请求的类型和URL。<strong>所有的XDR请求都是异步</strong>的。</p>
<p>过程：对于这种普通请求（GET、POST、HEAD），浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。<strong>CORS的基本思想是，使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</strong></p>
<pre><code>//考虑兼容性    
function createCORSRequest(method,url){
    var xhr=new XMLHttpRequest();
    if(&quot;withCredentials&quot; in xhr){
        xhr.open(method,url,true);//除IE8及以前版本的浏览器，使用XMLHttpRequest对象
    }
    else if(typeof XDomainRequest!=&quot;undefined&quot;){
        xhr =new XDomainRequest();
        xhr.open(method,url);//IE8及以前的版本所有XDR请求都是异步执行的，不能用他来创建同步请求
    }
    else{
        xhr=null;
    }
    return xhr;
}

var request=createCORSRequest(&quot;get&quot;,&quot;http://www.somewhere-else.com/page/&quot;);
if(request){
    request.onload=function(){
        //对request.responseText进行处理
    };
    request.send(null);
}
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ajax </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[readyState状态属性、Http状态码（status）]]></title>
      <url>/2017/08/03/ajax_%E7%8A%B6%E6%80%81%E7%A0%81_http%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>转载至：<a href="https://cwjinterview.github.io/2017/04/23/HTTP状态码/" title="HTTP状态码" target="_blank" rel="external">https://cwjinterview.github.io/2017/04/23/HTTP状态码/</a></p>
<h1 id="readyState属性值"><a href="#readyState属性值" class="headerlink" title="readyState属性值"></a>readyState属性值</h1><p>我们通常会通过ajax方法发送异步请求让 JavaScript 继续执行而不必等待响应。此时，可以检测 XMLHttpRequest 对象的 readyState 属性，该属性表示请求/响应过程中的当前活动阶段。这个属性可取的值如下：</p>
<ul>
<li>0：未初始化。尚未调用 open() 方法。</li>
<li>1：启动。已经调用 open() 方法，但尚未调用 send() 方法。</li>
<li>2：发送。已经调用 send() 方法，但尚未接收响应。</li>
<li>3：接收。已经接收到部分响应数据。</li>
<li>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。<h1 id="HTTP状态码-status"><a href="#HTTP状态码-status" class="headerlink" title="HTTP状态码(status)"></a>HTTP状态码(status)</h1></li>
</ul>
<p>HTTP状态码的英文为HTTP Status Code。</p>
<p>200 - 请求成功</p>
<p>301 - 资源（网页等）被永久转移到其它URL</p>
<p>404 - 请求的资源（网页等）不存在</p>
<p>500 - 内部服务器错误</p>
<p>302 Found   临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p>
<p>304 Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会<strong>缓存</strong>访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>
<h1 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h1><p>分类  分类描述</p>
<p>1** 信息，服务器收到请求，需要请求者继续执行操作</p>
<p>2** 成功，操作被成功接收并处理</p>
<p>3** 重定向，需要进一步的操作以完成请求</p>
<p>4** 客户端错误，请求包含语法错误或无法完成请求</p>
<p>5** 服务器错误，服务器在处理请求的过程中发生了错误</p>
<h1 id="HTTP状态码列表–详细"><a href="#HTTP状态码列表–详细" class="headerlink" title="HTTP状态码列表–详细"></a>HTTP状态码列表–详细</h1><ol>
<li><p>100 Continue    继续。客户端应继续其请求</p>
</li>
<li><p>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</p>
</li>
<li>200 OK  请求成功。一般用于GET与POST请求</li>
<li>201 Created 已创建。成功请求并创建了新的资源</li>
<li>202 Accepted    已接受。已经接受请求，但未处理完成</li>
<li>203 Non-Authoritative Information   非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</li>
<li>204 No Content  无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li>
<li>205 Reset Content   重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li>
<li><p>206 Partial Content 部分内容。服务器成功处理了部分GET请求</p>
</li>
<li><p>300 Multiple Choices    多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p>
</li>
<li>301 Moved Permanently   永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li>
<li>302 Found   临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li>
<li>303 See Other   查看其它地址。与301类似。使用GET和POST请求查看</li>
<li>304 Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>
<li>305 Use Proxy   使用代理。所请求的资源必须通过代理访问</li>
<li>306 Unused  已经被废弃的HTTP状态码</li>
<li><p>307 Temporary Redirect  临时重定向。与302类似。使用GET请求重定向</p>
</li>
<li><p>400 Bad Request 客户端请求的语法错误，服务器无法理解</p>
</li>
<li>401 Unauthorized    请求要求用户的身份认证</li>
<li>402 Payment Required    保留，将来使用</li>
<li>403 Forbidden   服务器理解请求客户端的请求，但是拒绝执行此请求</li>
<li>404 Not Found   服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li>
<li>405 Method Not Allowed  客户端请求中的方法被禁止</li>
<li>406 Not Acceptable  服务器无法根据客户端请求的内容特性完成请求</li>
<li>407 Proxy Authentication Required   请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</li>
<li>408 Request Time-out    服务器等待客户端发送的请求时间过长，超时</li>
<li>409 Conflict    服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</li>
<li>410 Gone    客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</li>
<li>411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息</li>
<li>412 Precondition Failed 客户端请求信息的先决条件错误</li>
<li>413 Request Entity Too Large    由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</li>
<li>414 Request-URI Too Large   请求的URI过长（URI通常为网址），服务器无法处理</li>
<li>415 Unsupported Media Type  服务器无法处理请求附带的媒体格式</li>
<li>416 Requested range not satisfiable 客户端请求的范围无效</li>
<li>417 Expectation Failed  服务器无法满足Expect的请求头信息</li>
<li>500 Internal Server Error   服务器内部错误，无法完成请求</li>
<li>501 Not Implemented 服务器不支持请求的功能，无法完成请求<br>502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</li>
<li>503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</li>
<li>504 Gateway Time-out    充当网关或代理的服务器，未及时从远端服务器获取请求</li>
<li>505 HTTP Version not supported  服务器不支持请求的HTTP协议的版本，无法完成处理</li>
</ol>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 状态码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写一个兼容addEventListener()和attachEvent()的方法]]></title>
      <url>/2017/08/03/%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E5%85%BC%E5%AE%B9ie%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function addEvent(elem,type,fn){
    if(elem.addEventListener){
        elem.addEventListener(type,fn,false);
    }else if(elem.attachEvent){
        elem[type+fn]=function(){
            fn.call(elem);;
        };
        elem.attachEvent(&apos;on&apos;+type,elem[type+fn]);
    }else{
        elem[&apos;on&apos;+type]=fn;
    }
}
&lt;/script&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript_事件监听 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[事件绑定、事件冒泡、事件代理]]></title>
      <url>/2017/08/03/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%81%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>转载至：<a href="https://cwjinterview.github.io/2017/04/23/事件冒泡捕获/" title="事件冒泡捕获" target="_blank" rel="external">https://cwjinterview.github.io/2017/04/23/事件冒泡捕获/</a></p>
<h1 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h1><p>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</p>
<p>事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。</p>
<p>所有浏览器都支持事件冒泡，但在具体实现上还有一些差别。</p>
<p>  IE 5.5: div -&gt; body -&gt; document（会跳过&lt;html&gt;元素，从&lt;body&gt;直接跳到document）</p>
<p>  IE 6.0: div -&gt; body -&gt; html -&gt; document</p>
<p>  Mozilla 1.0: div -&gt; body -&gt; html -&gt; document -&gt; window</p>
<h1 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h1><p>捕获型事件：事件从最不精确的对象(document 对象)开始触发，然后到最精确</p>
<p>事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。</p>
<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><p>同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束<br><img src="http://files.jb51.net/file_images/article/201310/20131028160201571.jpg" alt=""></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>IE浏览器只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。</p>
<pre><code>ele.addEventListener(&apos;click&apos;,doSomething2,true)

true=捕获

false=冒泡
</code></pre><h1 id="阻止事件冒泡和捕获"><a href="#阻止事件冒泡和捕获" class="headerlink" title="阻止事件冒泡和捕获"></a>阻止事件冒泡和捕获</h1><ol>
<li><p>在除IE以外其他的浏览器中通过e.stopPropagation()方式阻止事件的冒泡。在 支持该方法的浏览器中还有一个方法stopimmediatePropagation()，该方法不仅会组织事件向祖元素的冒泡，同时也会阻止同一个节点 上同一事件的其他的事件处理程序的执行，该方法比前者阻止的更彻底。</p>
</li>
<li><p>在IE浏览器中通过e.cancleBubble=true,阻止事件冒泡。</p>
</li>
</ol>
<h1 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h1><p>又称事件委托，就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p>##为什么会使用事件代理/委托</p>
<p>一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？</p>
<p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p>
<p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。</p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript_事件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写一个通用的事件绑定函数]]></title>
      <url>/2017/08/03/%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>写一个可以给标签直接绑定事件，并且还可以实现事件代理时的事件绑定的方法</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;title&gt;写一个通用的事件绑定函数&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;a href=&quot;#&quot; id=&quot;imooc1&quot;&gt;imooc1&lt;/a&gt;
        &lt;a href=&quot;http://imooc.com&quot; id=&quot;imooc2&quot;&gt;imooc2&lt;/a&gt;
        &lt;a href=&quot;http://imooc.com&quot; id=&quot;imooc3&quot;&gt;imooc3&lt;/a&gt;
        &lt;a href=&quot;http://imooc.com&quot; id=&quot;imooc4&quot;&gt;imooc4&lt;/a&gt;
        &lt;a href=&quot;http://imooc.com&quot; id=&quot;imooc5&quot;&gt;imooc5&lt;/a&gt;
        &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt;
    &lt;/div&gt;
    &lt;!-- &lt;div id=&quot;div2&quot;&gt;
        &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt;
        &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt;
    &lt;/div&gt; --&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function bindEvent(elem,type,selector,fn){
            if(fn==null){
                fn=selector;
                selector=null;
            }
            elem.addEventListener(type,function(e){
                if(selector){//代理
                    target=e.target;
                    if(target.matches(selector)){
                        fn.call(target,e);
                    }
                }else{
                    fn(e);
                }
            });
        }

        //调用
        //有代理的：点击哪个链接，显示哪个链接的内容
        var div1=document.getElementById(&quot;div1&quot;);
        bindEvent(div1,&apos;click&apos;,&apos;a&apos;,function(e){
            e.preventDefault();//阻止默认行为
            alert(this.innerHTML);
        });

        //没有代理的：点击id为p1的标签，显示&quot;激活&quot;
        var p1=document.getElementById(&quot;p1&quot;);
        bindEvent(p1,&apos;click&apos;,function(e){
            e.stopPropagation();//阻止默认行为
            e.cancleBubble=true;
            alert(&quot;激活&quot;);
        });

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript_事件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BOM操作]]></title>
      <url>/2017/08/03/BOM%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="一、如何检测浏览器的类型"><a href="#一、如何检测浏览器的类型" class="headerlink" title="一、如何检测浏览器的类型"></a>一、如何检测浏览器的类型</h3><p><strong>navigator对象</strong></p>
<blockquote>
<table table="" cellspacing="0" style="border:1px solid #e6e6e6;text-align:left"><tr><th>属性</th><th>描述</th></tr><tr><td>appCodeName</td><td>返回浏览器的代码名。</td></tr><tr><td>appMinorVersion</td><td>返回浏览器的次级版本。</td></tr><tr><td>appName</td><td>返回浏览器的名称。</td></tr><tr><td>appVersion</td><td>返回浏览器的平台和版本信息。</td></tr><tr><td>browserLanguage</td><td>返回当前浏览器的语言。</td></tr><tr><td>cookieEnabled</td><td>返回指明浏览器中是否启用 cookie 的布尔值。</td></tr><tr><td>cpuClass</td><td>返回浏览器系统的 CPU 等级。</td></tr><tr><td>onLine</td><td>返回指明系统是否处于脱机模式的布尔值。</td></tr><tr><td>platform</td><td>返回运行浏览器的操作系统平台。</td></tr><tr><td>systemLanguage</td><td>返回 OS 使用的默认语言。</td></tr><tr><td>userAgent</td><td>返回由客户机发送服务器的 user-agent 头部的值。</td></tr><tr><td>userLanguage</td><td>返回 OS 的自然语言设置。</td></tr></table>

</blockquote>
<pre><code>var ua=navigator.userAgent;
var reg=/chrome/i;
var isChrome=reg.test(ua);
console.log(isChrome);
</code></pre><h3 id="二、拆解url的各个部分"><a href="#二、拆解url的各个部分" class="headerlink" title="二、拆解url的各个部分"></a>二、拆解url的各个部分</h3><p><strong>location对象</strong></p>
<blockquote>
<table table="" cellspacing="0" style="border:1px solid #e6e6e6;text-align:left"><tr><th>属性</th><th>例子</th><th>描述</th></tr><tr><td>href</td><td>“<a href="http://www.wrox.com/WileyCDA/" target="_blank" rel="external">http://www.wrox.com/WileyCDA/</a>“</td><td>设置或返回完整的 URL。</td></tr><tr><td>protocol</td><td>“http”</td><td>设置或返回当前 URL 的协议。</td></tr><tr><td>pathname</td><td>“/WileyCDA/“</td><td>设置或返回当前 URL 的路径部分。</td></tr><tr><td>search</td><td>“?q=javascript”</td><td>设置或返回从问号 (?) 开始的 URL（查询部分）。</td></tr><tr><td>hash</td><td>“#content”</td><td>设置或返回从井号 (#) 开始的 URL（锚）。</td></tr><tr><td>host</td><td>“www.wrox.com:80”</td><td>设置或返回主机名和当前 URL 的端口号(如果有的话)。</td></tr><tr><td>hostname</td><td>“www.wrox.com”</td><td>设置或返回当前 URL 的主机名。</td></tr><tr><td>port</td><td>“8080”</td><td>设置或返回当前 URL 的端口号。</td></tr></table>

</blockquote>
<p>面试题：有一个页面，url为’<a href="http://qq.com?pet=cat&amp;age=2&amp;like=fish&#39;,设计一个函数将url附带的参数转换为对象返回" target="_blank" rel="external">http://qq.com?pet=cat&amp;age=2&amp;like=fish&#39;,设计一个函数将url附带的参数转换为对象返回</a></p>
<pre><code>function getParamObj(url){
    var startIndex =url.indexOf(&apos;?&apos;)+1;
    var subParam=url.substring(startIndex,url.length);
    var arrParam=subParam.split(&apos;&amp;&apos;);
    var objParam=new Object();//注意：初始化一个对象
    for(var i=0;i&lt;arrParam.length;i++){
        var arrSingle=arrParam[i].split(&apos;=&apos;);
        objParam[arrSingle[0]]=arrSingle[1];//注意：对象属性的赋值方法obj[key]=value
    }
    return objParam;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[将url附带的参数转换为对象返回]]></title>
      <url>/2017/08/03/%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9A%E5%B0%86url%E9%99%84%E5%B8%A6%E7%9A%84%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AF%B9%E8%B1%A1%E8%BF%94%E5%9B%9Emd/</url>
      <content type="html"><![CDATA[<p>面试题：有一个页面，url为’<a href="http://qq.com?pet=cat&amp;age=2&amp;like=fish&#39;,设计一个函数将url附带的参数转换为对象返回" target="_blank" rel="external">http://qq.com?pet=cat&amp;age=2&amp;like=fish&#39;,设计一个函数将url附带的参数转换为对象返回</a></p>
<pre><code>function getParamObj(url){
    var startIndex =url.indexOf(&apos;?&apos;)+1;
    var subParam=url.substring(startIndex,url.length);
    var arrParam=subParam.split(&apos;&amp;&apos;);
    var objParam=new Object();//注意：初始化一个对象
    for(var i=0;i&lt;arrParam.length;i++){
        var arrSingle=arrParam[i].split(&apos;=&apos;);
        objParam[arrSingle[0]]=arrSingle[1];//注意：对象属性的赋值方法obj[key]=value
    }
    return objParam;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用createDocumentFragment()方法]]></title>
      <url>/2017/08/02/%E4%BD%BF%E7%94%A8createDocumentFragment()/</url>
      <content type="html"><![CDATA[<p>假如想创建十个段落，使用常规的方式可能会写出这样的代码：</p>
<pre><code>for(var i = 0 ; i &lt; 10; i ++) {
    var p = document.createElement(&quot;p&quot;);
    var oTxt = document.createTextNode(&quot;段落&quot; + i);
    p.appendChild(oTxt);
    document.body.appendChild(p);
}
</code></pre><p>当然，这段代码运行是没有问题，但是他调用了十次document.body.appendChild()，每次都要产生一次页面渲染。这时碎片就十分有用了：</p>
<pre><code>var oFragment = document.createDocumentFragment();

for(var i = 0 ; i &lt; 10; i ++) {
    var p = document.createElement(&quot;p&quot;);
    var oTxt = document.createTextNode(&quot;段落&quot; + i);
    p.appendChild(oTxt);
    oFragment.appendChild(p);&lt;br data-filtered=&quot;filtered&quot;&gt;}
1
document.body.appendChild(oFragment);
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM操作]]></title>
      <url>/2017/08/02/DOM%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>DOM是文档对象模型(Document Object Model)，是W3C出台的推荐标准。其赋予了JS操作节点的能力。当网页被加载时，浏览器就会创建页面的文档对象模型。</p>
<p>可以理解为：浏览器把拿到的html代码，<strong>结构化</strong>成一个浏览器<strong>能识别</strong>并且js<strong>可操作</strong>的模型。</p>
<p>DOM被构造为对象的<strong>树</strong>。</p>
<h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><h3 id="一、新增节点"><a href="#一、新增节点" class="headerlink" title="一、新增节点"></a>一、新增节点</h3><p>（1）createElement();——创建元素节点</p>
<p>（2）createTextNode();——创建文本节点</p>
<p>（3）createDocumentFragment();——创建一个虚拟DOM片段</p>
<pre><code>var oFragment = document.createDocumentFragment();

for(var i = 0 ; i &lt; 10; i ++) {
    var p = document.createElement(&quot;p&quot;);
    var oTxt = document.createTextNode(&quot;段落&quot; + i);
    p.appendChild(oTxt);
    oFragment.appendChild(p);&lt;br data-filtered=&quot;filtered&quot;&gt;
}

document.body.appendChild(oFragment);
</code></pre><h3 id="二、插入节点"><a href="#二、插入节点" class="headerlink" title="二、插入节点"></a>二、插入节点</h3><p>（1）appendChild(newNode);——插入新创建的节点；也可以将已有的节点移动位置</p>
<pre><code>//新增节点
var p=document.createElement(&quot;p&quot;);
p.innerHTML=&quot;new p&quot;;
var div1=document.getElementById(&quot;div1&quot;);
div1.appendChild(p);

//移动节点
var p4=document.getElementById(&quot;p4&quot;);
div1.appendChild(p4);
</code></pre><p>（2）insertBefore(newNode,existingNode);</p>
<pre><code>//移动某个列表项到另一个列表项：
var node=document.getElementById(&quot;myList2&quot;).lastChild;
var list=document.getElementById(&quot;myList1&quot;);
list.insertBefore(node,list.childNodes[0]);
</code></pre><h3 id="三、删除节点"><a href="#三、删除节点" class="headerlink" title="三、删除节点"></a>三、删除节点</h3><p>（1）removeChild();</p>
<pre><code>var div1=document.getElementById(&quot;div1&quot;);
var childNodes=div1.childNodes;//有五个，其中包括三个空的text
div1.removeChild(childNodes[1]);
</code></pre><h3 id="四、替换节点"><a href="#四、替换节点" class="headerlink" title="四、替换节点"></a>四、替换节点</h3><p>（1）replaceChild(newnode,oldnode);</p>
<pre><code>var textnode=document.createTextNode(&quot;Water&quot;);
var item=document.getElementById(&quot;myList&quot;).childNodes[0];
item.replaceChild(textnode,item.childNodes[0]);
</code></pre><h3 id="五、获取父节点"><a href="#五、获取父节点" class="headerlink" title="五、获取父节点"></a>五、获取父节点</h3><p>（1）node.parentNode;</p>
<pre><code>//获取父元素
var p4=document.getElementById(&quot;p4&quot;);
console.log(p4.parentNode);
</code></pre><h3 id="六、获取子节点"><a href="#六、获取子节点" class="headerlink" title="六、获取子节点"></a>六、获取子节点</h3><p><strong>节点的类型：nodeType</strong></p>
<pre><code>元素类型    节点类型
元素            1
属性            2
文本            3
注释            8
文档            9
</code></pre><p>（1）node.childNodes;</p>
<pre><code>for (var i = 0; i &lt; oList.childNodes.length; i++) {//oList是做的ul的对象。  
    //nodeType是节点的类型，利用nodeType来判断节点类型，再去控制子节点  
    if (oList.childNodes[i].nodeType == 1) {//查找到oList内的元素节点  
        console.log(oList.childNodes[i]);//在控制器日志中显示找到的元素节点  
    }  
} 
</code></pre><p>（2）node.children;</p>
<p>children也可以获取子节点，而且兼容各种浏览器,包括IE6-8</p>
<p>（3）node.firstChild和node.firstElementChild</p>
<p>查找第一个子节点。此存在浏览器兼容问题：firstChild是IE兼容，firstElementChild是非IE（6，7，8）兼容。</p>
<p>（4）node.lastChild和node.lastElementChild</p>
<p>查找最后一个子节点。此存在浏览器兼容问题：lastChild 是IE兼容，lastElementChild是非IE兼容。</p>
<p>（5）node.nextSbling;–&gt;查找下一个兄弟节点。</p>
<p>（6）node.previousSbling;–&gt;查找上一个兄弟节点。</p>
<h3 id="七、查找节点"><a href="#七、查找节点" class="headerlink" title="七、查找节点"></a>七、查找节点</h3><p>（1）document.getElementById();</p>
<p>（2）document.getElementsByTagName();</p>
<p>（3）document.getElementsByName();</p>
<p>（4）document.getElementsByClassName();</p>
<p>IE9以下的版本却不支持document.getElementsByClassName方法，<font color="red">有兼容性问题</font>，可使用原生JS模拟重新实现。</p>
<p><strong>解析</strong>：通过获取指定的标签，使用getElementsByTagName来获取标签内容，然后根据标签的className跟传进来的参数进行对比，如果相等就插入数组，最后返回数组。</p>
<pre><code>function getClassNames(classStr,tagName){  
      if (document.getElementsByClassName) {  
            return document.getElementsByClassName(classStr)  
      }else {  
            var nodes = document.getElementsByTagName(tagName),ret = [];           
            for(i = 0; i &lt; nodes.length; i++) {  
             if(hasClass(nodes[i],classStr)){  
                 ret.push(nodes[i])  
             }  
          }  
            return ret;  
      }  
}  
function hasClass(tagStr,classStr){  
     var arr=tagStr.className.split(/\s+/ );  //这个正则表达式是因为class可以有多个,判断是否包含  
     for (var i=0;i&lt;arr.length;i++){  
            if (arr[i]==classStr){  
                  return true ;  
            }  
     }  
     return false ;  
}  

//调用
var  divs = getClassNames(&apos;tabs_div&apos; , &apos;div&apos;);  
</code></pre><p>（5）document.querySelectorAll();</p>
<pre><code>//综合例子    
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;DOM节点获取&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot; class=&quot;class-div1&quot;&gt;
        &lt;p id=&quot;p1&quot; data-name=&quot;p1-data-name&quot;&gt;this is p1&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;this is p2&lt;/p&gt;
    &lt;/div&gt;
    &lt;div id=&quot;div2&quot;  name=&quot;div2&quot;&gt;
        &lt;p id=&quot;p3&quot;&gt;this is p3&lt;/p&gt;
        &lt;p id=&quot;p4&quot;&gt;this is p4&lt;/p&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var div1=document.getElementById(&quot;div1&quot;);
        var divList=document.getElementsByTagName(&quot;div&quot;);
        var div2=document.getElementsByName(&quot;div2&quot;)[0];
        console.log(div2);
        console.log(divList.length);
        console.log(divList[0]);
        var pList=document.getElementsByClassName(&quot;class-div1&quot;);
        console.log(pList);
        var pListAll=document.querySelectorAll(&quot;p&quot;);
        console.log(pListAll);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="DOM节点的Attribute和property"><a href="#DOM节点的Attribute和property" class="headerlink" title="DOM节点的Attribute和property"></a>DOM节点的Attribute和property</h2><p>区别：property:只是一个JS对象的属性的获取、修改<br><br>attribute:是对html标签属性的获取修改</p>
<pre><code>//property
var div1=document.getElementById(&quot;div1&quot;);
console.log(div1.className);
div1.className=&quot;abc&quot;;
console.log(div1.className);

//attribute
var p1=document.getElementById(&quot;p1&quot;);
console.log(p1.getAttribute(&quot;data-name&quot;));
p1.setAttribute(&quot;data-name&quot;,&quot;aaa&quot;);
console.log(p1.getAttribute(&quot;data-name&quot;));
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写一个能遍历对象和数组的forEach函数]]></title>
      <url>/2017/08/02/%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84forEach%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><strong>解析</strong>：数组API中有forEach(function(item,index){})方法，但是需要注意参数的顺序；而对象是通过for(…in..)方法实现遍历。</p>
<p><strong>小贴士</strong>：在编码实现的过程中，可以先考虑如何去调用，然后再暗要求实现函数定义。</p>
<pre><code>function forEach(obj,fn){
    if(obj instanceof Array){
        obj.forEach(function(item,index){
            fn(index,item);
        });
    }
    else{
        for(var key in obj){
            if(obj.hasOwnProperty(key)){
                fn(key,obj[key]);
            }
        }
    }
}

//调用
var arr=[1,2,3,4];
forEach(arr,function(index,item){
    console.log(index,item);
});

var obj={
    a:100,
    b:200,
    c:300
};
forEach(obj,function(key,value){
    console.log(key,value);
});
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> forEach </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写一个生成num个在[min-max]之间的随机整数函数]]></title>
      <url>/2017/08/02/%E5%86%99%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90num%E4%B8%AA%E5%9C%A8%5Bmin-max%5D%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B4%E6%95%B0%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><strong>解析</strong>：</p>
<ul>
<li>Math.random()方法返回大于等于0小于1的一个随机数；</li>
<li>Math.ceil()方法执行向上舍入，即大于等于当前数；</li>
<li>Math.floor()方法执行向下舍入，即小于等于当前数；</li>
<li><p>Math.round()方法标准舍入（四舍五入）</p>
<pre><code>function setArr(num,min,max){
    if(max&gt;min){
        var range=max-min;
        var arr=[];
        for(var i=0;i&lt;num;i++){
            var value=Math.floor(Math.random()*range)+min;
            arr.push(value);
        }
        return arr;
    }    
}

setArr(22,0,15);
</code></pre></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端小例子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> forEach </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[异步和单线程]]></title>
      <url>/2017/08/02/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-什么是异步，和同步有什么异同"><a href="#1-什么是异步，和同步有什么异同" class="headerlink" title="1.什么是异步，和同步有什么异同"></a>1.什么是异步，和同步有什么异同</h3><p>同步会阻塞代码的执行，而异步不会。 简单的例子，alert()是同步，setTimeout()是异步。</p>
<pre><code>1.   console.log(100);
2.   setTimeout(fucntion(){
3.       console.log(200);
4.   },1000);
5.   console.log(300);
6.   
7.    //结果
8.    100
9.    300
10.    200
</code></pre><p><br></p>
<pre><code>11.    console.log(100);
12.    alert(200);//有阻塞，卡顿
13.    console.log(300);
</code></pre><p><strong>JavaScript引擎解析是一个单线程的过程</strong>,浏览器无论在任何时候有且只有一个线程在运行Javascript程序，如果没有异步的话，单线程会出现“卡顿”。上边例子体现了JS中单线程和异步的关系（执行过程如下）：</p>
<p>（1）执行第1行,打印100；</p>
<p>（2）执行第2行setTimeout后，传入setTimeout的函数会被<strong>暂存</strong>起来，<strong>不会立即执行</strong>（<font color="red">单线程的特点：不会同时执行两件事</font>）</p>
<p>（3）执行第5行，打印300；</p>
<p>（4）待所有程序执行完，处于空闲状态时，会立即查看又有没有暂存起来要执行的；</p>
<p>（5）发现暂存起来的setTimeout中的函数，等待1000ms，开始执行，打印出200.</p>
<h3 id="2-前端使用异步的场景"><a href="#2-前端使用异步的场景" class="headerlink" title="2.前端使用异步的场景"></a>2.前端使用异步的场景</h3><p>在实际开发应用中，需要等待的地方，就会用到异步。</p>
<ol>
<li><p>定时任务：setTimeout()、setInterval()</p>
<pre><code>console.log(100);
setTimeout(function(){
    console.log(200);
},1000)
console.log(300);             
</code></pre></li>
<li><p>网络请求：ajax请求，动态<img>加载</p>
<pre><code>//使用异步的场景——ajax请求（此例子需要完善）
 console.log(&quot;start&quot;);
 $.get(&apos;test-test.json&apos;,function(data){
     console.log(data);
 })
 console.log(&quot;end&quot;);

//网络请求图片加载
 console.log(&quot;start&quot;);
 var img=document.createElement(&apos;img&apos;);
 img.onload=function(){
     console.log(&apos;loaded&apos;);
 }
 img.src=&apos;http://pic6.huitu.com/res/20130116/84481_20130116142820494200_1.jpg&apos;;        
 console.log(&quot;end&quot;)
</code></pre></li>
<li><p>事件绑定</p>
<pre><code>//事件绑定
console.log(&quot;start&quot;);
var btn1=document.getElementById(&quot;btn1&quot;);
btn1.addEventListener(&apos;click&apos;,function(){
    console.log(&quot;clicked&quot;);
});
console.log(&quot;end&quot;);
</code></pre></li>
</ol>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript_this的几种使用场景]]></title>
      <url>/2017/08/02/this%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<p>this在定义的时候是确定不了的，只有其在函数执行的时候才能确认值。一般而言，在JavaScript中this指向函数执行时的当前对象，谁调用的就指向谁。</p>
<ol>
<li><p>作为构造函数调用，this 指代new 出的对象</p>
<pre><code>function Foo(name){
    //this={};
    this.name=name;
    //return this;
}
var f=new Foo(&apos;zhangsan&apos;);
</code></pre></li>
<li><p>作为对象属性方法调用，this 指代上级对象</p>
<pre><code>var obj={
    name:&apos;A&apos;,
    printName:function(){
        name:&apos;B&apos;;
        console.log(this.name);
    }
}

obj.printName();
</code></pre></li>
<li><p>作为普通对象函数执行，this指代全局对象</p>
<pre><code>function fn(){
    console.log(this);//this===window
}

fn();
</code></pre></li>
<li><p>在call,apply,bind中使用，此方法的第一个参数为改变后调用这个函数的对象，this指代第一个参数</p>
<pre><code>function fn1(name){
    alert(name);
    console.log(this);
}

fn1.call({x:100},&quot;zhangsan&quot;);//这时fn1中的this就是{x:100}

fn1.apply({x:100},[&quot;zhangsan&quot;,20]);//这时fn1中的this就是{x:100}

//bind使用时需要是函数表达式的形式
var fn3 = function (name,age){
    alert(name);
    console.log(this);
}.bind({y:200})//这时fn3中的this是{y:200}
fn3(&apos;zhangsan&apos;,20);
</code></pre></li>
</ol>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> this </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[作用域和闭包]]></title>
      <url>/2017/08/02/javascript_%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
<p>闭包的使用场景：</p>
<ul>
<li>函数作为返回值</li>
<li>函数作为参数传递</li>
</ul>
<h2 id="javascript中变量的作用域"><a href="#javascript中变量的作用域" class="headerlink" title="javascript中变量的作用域"></a>javascript中变量的作用域</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。JS中无块级作用域，只有函数作用域和全局作用域。</p>
<pre><code>if(true){
    var color=&quot;blue&quot;;
}

console.log(color);//&quot;blue&quot;-&gt;因为对JavaScript来说，没有块级作用域，所以不会报错
</code></pre><p>1.执行上下文 </p>
<p>全局作用域：在一段&lt;script&gt;中，在执行之前回把函数的声明和变量的声明提到最前面。</p>
<pre><code>console(a);//undefined
var a=10;
</code></pre><p>函数作用域：在函数之前之前，函数中也会将变量和函数的声明提到函数中的前面。</p>
<font color="red">注：函数声明和函数表达式不同。</font>

<pre><code>fn();//不会报错
function fn(){
    //声明
}
</code></pre><p><br></p>
<pre><code>fu()；//会报错
var fn=function(){
    //表达式
}；
</code></pre><p>区别：函数声明在JS解析时进行函数<strong>提升</strong>，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JS运行时确定，并且在表达式赋值完成后，该函数才能调用。</p>
<p>2.作用域链</p>
<p>​ <strong>作用域链</strong>，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。<br><br>体现在自由变量（即在当前作用域中没有定义的变量）的值要去其父作用域中找。<strong>父作用域</strong>是指定义它的作用域，而不是执行它的作用域。</p>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><p>实际开发过程中，闭包用来封装变量，收敛权限。</p>
<p>（1）使用闭包可以在javascript中模仿块级作用域。</p>
<p>创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。</p>
<p>结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。</p>
<pre><code>//创建10个&lt;a&gt;标签的点击的时候弹出对应的序号
var i;
for(i=0;i&lt;10;i++){//自执行函数
    (function(i){
        //i函数作用域
        var a=document.createElement(&apos;a&apos;);
        a.innerHTML=i+&quot;&lt;br&gt;&quot;;
        a.addEventListener(&apos;click&apos;,function(e){
            e.preventDefault();//阻止a标签的默认事件
            alert(i);//i是自由变量，需要去父作用域获取值，此处无块级作用域，所以i是全局作用域，最后弹出无论点击哪个都是10
        });
        document.body.appendChild(a);
    })(i)
}

//自执行函数：就是不用调用，只要定义完成，立即执行的函数
</code></pre><p>(2) 用于在对象中创建私有变量。</p>
<ul>
<li><p>即使JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量</p>
</li>
<li><p>有权访问私有变量的公有方法叫做特权方法</p>
</li>
</ul>
<p>如下所示，在isFirstLoad 函数外面，根本不能修改掉_list 的值</p>
<pre><code>function isFirstLoad(){
    var _list=[]; 
    return function(id){
        if(_list.indexOf(id)&gt;=0){
            return false;    
        }
        else{
            _list.push(id);
            return true;
        }
    }
}

var firstLoad=isFirstLoad();
firstLoad(10);//true
firstLoad(10);//false
firstLoad(20);//true
firstLoad(20);//false
</code></pre><h2 id="闭包中的问题"><a href="#闭包中的问题" class="headerlink" title="闭包中的问题"></a>闭包中的问题</h2><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 </p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[new一个对象的过程]]></title>
      <url>/2017/07/31/js_new%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>(1) 创建一个新对象</p>
<p>(2) 将构造函数的作用域赋给新对象，（因此this就指向了这个对象）</p>
<p>(3) 执行代码，即对this赋值</p>
<p>(4) 返回this</p>
<pre><code>//例子
function Foo(name,age){
    this.name=name;                    //(3)
    this.age=age;                    //(3)
    this.class=&quot;class-1&quot;;            //(3)
    //return this;        //默认有这一行(4)
}

var f1 = new Foo(&quot;zhangsan&quot;,23);    //(1)(2)
</code></pre><h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><h3 id="对象字面量的方式"><a href="#对象字面量的方式" class="headerlink" title="对象字面量的方式"></a>对象字面量的方式</h3><pre><code>var person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};
</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><pre><code>//工厂模式用函数来封装以特定接口创建对象的细节
function createPerson(name,age,job){
    var o=new Object();
    o.name=name;
    o.age=age;
    o.job=job;

    o.sayHi=function(){
        console.log(this.name);
    };
    return o;
}

var person1=createPerson(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);
person1.sayHi();//Nicholas
var person2=createPerson(&quot;Grey&quot;,27,&quot;Doctor&quot;);
person2.sayHi();//Grey
</code></pre><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>如下所示，在这个例子中，Person()函数取代了createPerson()函数。我们注意到，它俩的不同之处：<br><br>（1）没有显示地创建对象<br><br>（2）直接将属性和方法赋给了this对象<br><br>（3）没有return语句</p>
<pre><code>function Person(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;
    this.sayName=function(){
        console.log(this.name);
    };
}

var person1=new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);
var person2=new Person(&quot;Grey&quot;,27,&quot;Doctor&quot;);
</code></pre><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><pre><code>//利用函数的原型属性（prototype属性）
function Person(){

}
Person.prototype.name=&quot;Nicholas&quot;;
Person.prototype.age=29;
Person.prototype.job=&quot;SoftWare Engineer&quot;;
Person.prototype.sayName=function(){
    console.log(this.name);
}

var person1=new Person();
person1.sayName();//Nicholas

var person2=new Person();
person2.sayName();//Nicholas

console.log(person1.sayName==person2.sayName);//true

//可以利用isPrototypeOf()来判断对象之间是否存在原型系统与实例间的关系
console.log(Person.prototype.isPrototypeOf(person1));//true
</code></pre><h3 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h3><pre><code>//组合使用构造函数模式与原型模式，
function Person(name,age,job){
    this.name=name;
    this.age=age;
    this,job=job;
    this.friends=[&quot;Shelby&quot;,&quot;Court&quot;];
}

Person.prototype={
    constructor:Person,
    sayName:function(){
        console.log(this.name);
    }
}

var person1=new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);
var person2=new Person(&quot;Grey&quot;,21,&quot;Doctor&quot;);

person1.friends.push(&quot;Van&quot;);
console.log(person1.friends);//[ &apos;Shelby&apos;, &apos;Court&apos;, &apos;Van&apos; ]
console.log(person2.friends);//[ &apos;Shelby&apos;, &apos;Court&apos; ]

console.log(person1.friends===person2.friends);//false
console.log(person1.sayName===person2.sayName);//true
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> new，面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原型和原型链]]></title>
      <url>/2017/07/31/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<h3 id="原型规则"><a href="#原型规则" class="headerlink" title="原型规则"></a>原型规则</h3><blockquote>
<ol>
<li>所有的引用类型变量（对象，数组、函数），都有构造函数</li>
<li>所有引用类型变量（对象，数组、函数），都具有对象特性，即可自由扩展属性。</li>
<li>所有引用类型变量（对象，数组、函数），都有一个隐式原型属性（__proto__）,属性值也是一个普通的对象。</li>
<li><strong>所有函数</strong>都有一个显示原型属性（prototype)，属性值也是一个普通的对象。</li>
<li>当试图得到一个引用类型的某个属性是，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找。</li>
</ol>
</blockquote>
<h4 id="访问一个对象的属性过程体现了原型链规则"><a href="#访问一个对象的属性过程体现了原型链规则" class="headerlink" title="访问一个对象的属性过程体现了原型链规则"></a>访问一个对象的属性过程体现了原型链规则</h4><p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。<br></p>
<p>​ 在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空——执行上下文环境。<br></p>
<p>​ <strong>作用域链</strong>，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。<br></p>
<p>​ 每一个对象都会在内部链接到另一个对象(该对象的原型对象)，该对象有一个原型prototype，当访问对象的属性或是方法的时候，不仅仅会在原对象上查找，还会顺着原型链在原型对象的原型链上查找，直到查到null(所有原型链的顶层)为止。原型是JavaScript实现继承的基础，new关键字做的主要的事情就是将实例对象的__proto__属性指向原型对象的prototype。</p>
<h3 id="一个原型链继承的例子"><a href="#一个原型链继承的例子" class="headerlink" title="一个原型链继承的例子"></a>一个原型链继承的例子</h3><pre><code>function Elem(id){
    this.elem=document.getElementById(id);
}

Elme.prototype.html=function(var){
    var elem=this.elem;
    if(var){
        elem.innerHTML=val;
        return this;
    }else{
        return elem.innerHTML;
    }
}
Elem.prototype.on=function(type,fn){
    var elem=this.elem;
    elem.addEventListener(type,fn);
}
//实例
var div1=new Elem(&quot;div1&quot;);
div1.html(&quot;&lt;p&gt;hello&lt;/p&gt;&quot;);
div1.on(&apos;click&apos;,function(){
    alert(&apos;clicked&apos;);
});
</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>因 typeof 只能判断值类型数据的变量类型，但如果变量的值是一个对象或者null，则判断不了。为此提供了 instanceof 操作符，其语法如下所示</p>
<pre><code>result = variable instanceof constructor
//例如：
alert(person instanceof Object);
alert(colors instanceof Array);
alert(pattern instanceof RegExp);
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js基础知识，面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript数据类型]]></title>
      <url>/2017/07/31/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>Javascript按存储方式区分变量类型：值类型（也称基本数据类型）和引用数据类型。</p>
<h3 id="1-基本数据（值）类型"><a href="#1-基本数据（值）类型" class="headerlink" title="1.基本数据（值）类型"></a>1.基本数据（值）类型</h3><p>字符串型（String）；数值型（Number）;布尔型（Boolean）;未定义（undefined）；Null类型</p>
<h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h3><p>对象（Object）类型；数组类型（Array）；函数类型（function）</p>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><p>基本数据类型的变量存放的是基本类型数据的实际值；而引用数据类型的变量保存对它的引用，即指针。<br><br>引用数据类型好几个变量共用一个内存块，赋值一旦被修改，互相会有影响。</p>
<h3 id="4-需注意"><a href="#4-需注意" class="headerlink" title="4.需注意"></a>4.需注意</h3><p>(1) <strong>typeof</strong>只能区分值类型的详细类型，如果这个值是引用数据类型或者null，则区分不出来</p>
<pre><code>typeof 95            //&quot;number&quot;
typeof &apos;aa&apos;            //&quot;string&quot;
typeof true            //&quot;boolean&quot;
typeof undefined    //&quot;undefined&quot;
typeof null            //&quot;object&quot;

var o= new Object();
typeof o            //&quot;object&quot;
</code></pre><p>(2) <strong>null==undefined会返回true,但null===undefined会返回false。</strong>那么编码过程中，什么时候用“==”，什么时候用“===”呢？</p>
<p>a.对象的属性是否存在    </p>
<pre><code>if(obj.a==null){
    //这里相当于obj.a===null||obj.a==undefined，简写形式
    //这是jQuery源码中的推荐写法
}
</code></pre><p>b.函数的参数a是否存在</p>
<pre><code>function(a,b){
    if(a==null){
        ...
    }
}
</code></pre><font color="red">其他情况都用“===”。</font>

<p>(3)怎么判断一个变量a在if语句中是true还是false?</p>
<pre><code>!!(a);
</code></pre><font color="red">注：</font> 0，NaN，’’，null，false，undefined–&gt;会转换为false<br><br>(4)JS中的内置函数：Object，Array，Boolean，Number，String，Function，Date，RegExp，Error…<br><font color="red">Math是内置对象，不是函数。</font>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> js数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2014/03/16/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
