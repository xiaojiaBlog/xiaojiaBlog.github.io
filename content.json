[{"title":"Ajax和跨域","date":"2017-07-28T09:17:57.000Z","path":"2017/07/28/Ajax和跨域/","text":"1.考虑兼容IE7之前的浏览器，创建XHR对象function createXHR(){ if(typeof XMLHttpRequest!=&quot;undefined&quot;){ return new XMLHttpRequest(); }else if(typeof ActiveXObject!=&quot;undefined&quot;){ if(typeof arguments.callee.activeXString!=&quot;string&quot;){ var versions=[&quot;MSXML2.XMLHttp.6.0&quot;,&quot;MSXML2.XMLHttp.3.0&quot;,&quot;MSXML2.XMLHttp&quot;]; var i,len; for(i=0,len=versions.length;i&lt;len;i++){ try{ new ActiveXObject(versions[i]); arguments.callee.activeXString=versions[i]; break; }catch(ex){ //跳过 } } } return new ActiveXObject(arguments.callee.activeXString); }else{ throw new Error(&quot;No XHR object available.&quot;); } } //发送同步请求 var xhr=createXHR(); xhr.open(&quot;get&quot;,&quot;example.txt&quot;,&quot;false&quot;);//false表示同步发送请求 xhr.send(null);//null表示不需要请求主体发送数据 //在接到响应以后，第一步是检查status属性，以确定响应已成功返回 if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status==304){ alert(xhr.responseText); }else{ alert(&quot;Response was unsuccessfull:&quot;+xhr.status); } //ajax发送异步请求 var xhr=createXHR(); xhr.onreadyStateChange=function(){ if(xhr.readyState==4){ if((xhr.status&gt;=200&amp;&amp;shr.status&lt;300)||xhr.status==304){ alert(xhr.responseText); }else{ alert(&quot;Response was unsuccessfull:&quot;+xhr.status); } } }; xhr.open(&quot;get&quot;,&quot;example.txt&quot;,true); xhr.send(null); 2.跨浏览器的CORSCORS的基本思想是，使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 //考虑兼容性 function createCORSRequest(method,url){ var xhr=new XMLHttpRequest(); if(&quot;withCredentials&quot; in xhr){ xhr.open(method,url,true);//除IE8及以前版本的浏览器，使用XMLHttpRequest对象 } else if(typeof XDomainRequest!=&quot;undefined&quot;){ xhr =new XDomainRequest(); xhr.open(method,url);//IE8及以前的版本所有XDR请求都是异步执行的，不能用他来创建同步请求 } else{ xhr=null; } return xhr; } var request=createCORSRequest(&quot;get&quot;,&quot;http://www.somewhere-else.com/page/&quot;); if(request){ request.onload=function(){ //对request.responseText进行处理 }; request.send(null); } 3.JSONP实现跨域JSONP由两部分构成：回调函数和数据。回调函数,是当响应到来时，应该在页面中调用的函数。数据，是传入回调函数中的JSON数据。 function handleResponse(response){ alert(&quot;You&apos;re at IP address &quot;+response.ip+&quot;, which is in &quot;+response.city+&quot;, &quot;+response.region_name); } var script=document.createElement(&quot;script&quot;); script.src=&quot;http://freegeoip.net/json/?callback=handleResponse&quot;; document.body.insertBefore(script,document.body.firstChild); 4.ajax和jsonp实现跨域的区别（1） ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；（2）但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，使用XHR(XDR)对象并在open()方法中传入绝对URL；而jsonp的核心则是通过动态&lt;script&gt;元素来使用的，使用时可以为src属性指定一个跨域URL。 参考博文：https://cwjinterview.github.io/2017/04/23/%E6%89%8B%E5%86%99ajax/http://www.cnblogs.com/Darren_code/p/cors.html","tags":[{"name":"Javscript高级程序设计","slug":"Javscript高级程序设计","permalink":"http://feixiaoxiaojia.github.io/tags/Javscript高级程序设计/"},{"name":"前端跨域","slug":"前端跨域","permalink":"http://feixiaoxiaojia.github.io/tags/前端跨域/"}]},{"title":"JSON.stringify()","date":"2017-07-27T03:55:00.000Z","path":"2017/07/27/JSON方法stringify()/","text":"JSON.stringify()中可接受第二个参数：这个参数可以是一个数组（指过滤数组中列出的属性）；也可以是一个过滤函数：接受两个参数属性名和值。 var book={ title:&quot;Professional JavaScript&quot;, author:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011, print:function(){ console.log(this.title); }, num:undefined }; var jsonText=JSON.stringify(book); console.log(jsonText); //{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;author&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3,&quot;year&quot;:2011} //数组 var jsonTextPart=JSON.stringify(book,[&quot;title&quot;,&quot;author&quot;]); //{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;author&quot;:[&quot;Nicholas C. Zakas&quot;]} //函数 var jsonText=JSON.stringify(book,function(key,value){ switch(key){ case &quot;author&quot;: return value.join(&apos;,&apos;); case &quot;edition&quot;: return undefined; case &quot;year&quot;: return 5000; default: return value; } }); console.log(jsonText); //{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;author&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000} JSON.stringify()接受第三个参数：用来控制结果中的空白符和缩进符。最大缩进符为10。 var book={ title:&quot;Professional JavaScript&quot;, author:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011 }; var jsonText=JSON.stringify(book,null,4); //结果：每个级别缩进4个空格 // &quot;{ // &quot;title&quot;: &quot;Professional JavaScript&quot;, // &quot;author&quot;: [ // &quot;Nicholas C. Zakas&quot; // ], // &quot;edition&quot;: 3, // &quot;year&quot;: 2011 // }&quot; var jsonText2=JSON.stringify(book,null,&apos;--&apos;); //结果：以‘--’为缩进符 // &quot;{ // --&quot;title&quot;: &quot;Professional JavaScript&quot;, // --&quot;author&quot;: [ // ----&quot;Nicholas C. Zakas&quot; // --], // --&quot;edition&quot;: 3, // --&quot;year&quot;: 2011 // }&quot;","tags":[{"name":"Javscript高级程序设计","slug":"Javscript高级程序设计","permalink":"http://feixiaoxiaojia.github.io/tags/Javscript高级程序设计/"}]},{"title":"JSON.parse()","date":"2017-07-27T03:55:00.000Z","path":"2017/07/27/JSON方法parse()/","text":"JSON.parse()接收第二个参数，该参数是个函数（函数的参数分别是属性名和值，而且都需要返回一个值）。如果返回值是undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。 var book={ title:&quot;Professional JavaScript&quot;, author:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011, releaseDate:new Date(2011,11,1) }; var jsonText=JSON.stringify(book); var bookCopy=JSON.parse(jsonText,function(key,value){ if(key==&quot;releaseDate&quot;){ return new Date(value)//会使bookCopy.releaseDate属性中保存一个 //Date对象，这样才能使用getFullYear()方法 } else{ return value; } }); console.log(bookCopy); alert(bookCopy.releaseDate.getFullYear());","tags":[{"name":"Javscript高级程序设计","slug":"Javscript高级程序设计","permalink":"http://feixiaoxiaojia.github.io/tags/Javscript高级程序设计/"}]},{"title":"JSON基础知识学习","date":"2017-07-26T10:12:37.000Z","path":"2017/07/26/JSON/","text":"JSON是一种数据格式，不是一种编程语言。也是Javascript的一种内置对象。 语法JSON有三种类型的值：简单值、对象、数组 1.简单值：可以在JSON中表示字符串、数组、布尔值、null。但是JSON不支持Javascript中的特殊值undefined。 //数值 5 //字符串 &quot;Hello world&quot; //JSON字符串必须使用双引号 2.对象：与Javascript的对象字面量相比，JSON不同。首先，没有声明变量；其次，没有末尾的分号。 //javascript中对象 var object={ name:&quot;Tom&quot;, age:29 }; //json的表示对象方式 { &quot;name&quot;:&quot;Tom&quot;, &quot;age&quot;:29 } 3.数组：JSON中的数组也没有变量和分号 //简单的例子 [25,&quot;hi&quot;,true] //对象和数组结合 [ { &quot;title&quot;:&quot;Professional Javascript&quot;, &quot;author&quot;:[ &quot;Nichoals C. Zakas&quot; ], &quot;edition&quot;:3, &quot;year&quot;:2011 }, { &quot;title&quot;:&quot;Professional Javascript&quot;, &quot;author&quot;:[ &quot;Nichoals C. Zakas&quot; ], &quot;edition&quot;:2, &quot;year&quot;:2009 } ] 解析JSON对象有两个方法：stringify()和parse()。 JSON.stringify(obj);//把Javascript对象序列化为JSON字符串 JSON.parse(str);//将JSON字符串转换为原生的Javascript值 注：在序列化JS对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为undefined的任何属性也都会被跳过。 var book={ title:&quot;Professional JavaScript&quot;, author:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011， print:function(){ console.log(this.title); }, num:undefined }; var jsonText=JSON.stringify(book); console.log(jsonText); //{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;author&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3,&quot;year&quot;:2011} var bookCopy=JSON.parse(jsonText); //bookCopy和book有相同的属性，但他们是两个独立的、没有任何关系的对象。 toJSON():可以作为函数过滤器的补充。可以给对象定义toJSON()方法，返回其自身的JSON数据格式。 注：可以让toJSON()方法返回任何值，他都能正常工作。比如：可以让这个方法返回undefined，此时如果包含他的对象嵌入在另一个对象中，会导致它的值变成null，而如果他是顶级对象，结果就是undefined。 小结 假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下： (1) 如果存在toJSON()方法而且能通过他取得有效的值，则调用该方法。否则，返回对象本身。 (2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第（1）步返回的值。 (3) 对第（2）步返回的每个值进行相应的序列化。 (4) 如果提供了第三个参数，执行相应的格式化。","tags":[{"name":"Javscript高级程序设计","slug":"Javscript高级程序设计","permalink":"http://feixiaoxiaojia.github.io/tags/Javscript高级程序设计/"}]},{"title":"部分linux基本命令","date":"2017-07-20T01:57:00.000Z","path":"2017/07/20/linux基本命令/","text":"新建文件夹mkdir a //新建文件夹a ll //查看当前目录下的文件目录 详情 ls //查看当前目录下的文件目录 名称 cd a //转到a目录下 pwd //查看当前目录路径 cd .. //返回上一级目录 rm -rf a //删除文件夹a vi a.js //添加文件a.js cp a.js a1.js //拷贝文件a.js到a1.js mdkir src mv a1.js src/a1.js //移动a1.js到src文件夹下 rm a.js //删除文件 编辑文件vi/vim a.js //创建文件a.js，并编辑 i //进入编辑状态 Esc //退出编辑状态 Esc-&gt;:w //保存 Esc-&gt;:q //退出 Esc-&gt;:wq //保存并退出 查看文件内容vi a.js cat a.js //查看文件全部内容 head a.js //查看文件一开始的部分 tail a.js //查看文件末尾的部分 head -n 1 a.js //查看文件前一行 tail -n 2 a.js //查看文件后两行 grep &apos;2&apos; a.js //查看文件中出现‘2’的行 grep -v &apos;2&apos; a.js //查看文件中不出现‘2’的行","tags":[{"name":"面试","slug":"面试","permalink":"http://feixiaoxiaojia.github.io/tags/面试/"}]},{"title":"上线回滚流程要点","date":"2017-07-20T01:12:02.855Z","path":"2017/07/20/上线流程要点/","text":"上线流程要点 将测试完成的代码提交到git版本库的master分支 将当前服务器的代码全部打包并记录版本号，备份（如，v1.0） 将master分支的代码提交覆盖到线上服务器，生成新版本号（如，v1.1） 回滚流程要点 将当前服务器的代码打包并记录版本号，备份（如，v1.1） 将备份的上一个版本（如v1.0）号解压，覆盖到线上服务器，并生成新版本号（如，v1.2）","tags":[{"name":"面试","slug":"面试","permalink":"http://feixiaoxiaojia.github.io/tags/面试/"}]},{"title":"方法定义","date":"2017-07-19T03:26:00.000Z","path":"2017/07/19/Call_apply区别/","text":"转载：https://cwjinterview.github.io/2017/04/23/Call_apply区别/ Call方法语法：语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 定义：调用一个对象的一个方法，以另一个对象替换当前对象。 说明： call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法语法：apply([thisObj[,argArray]]) 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明： 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 唯一区别是apply接受的是数组参数，call接受的是连续参数。 实例&lt;script&gt; function add(j, k){ console.log(j+k); } function sub(j, k){ console.log(j-k); } add(5,3); //8 add.call(sub, 5, 3); //8 add.apply(sub, [5, 3]); //8 sub(5, 3); //2 sub.call(add, 5, 3); //2 sub.apply(add, [5, 3]); //2 &lt;/script&gt; 通过call和apply，我们可以实现对象继承。示例：var Parent = function(){ this.name = &quot;yjc&quot;; this.age = 22; } var child = {}; console.log(child);//Object {} ,空对象 Parent.call(child); console.log(child); //Object {name: &quot;yjc&quot;, age: 22} call、apply有什么作用我们经常会在我们项目中做一些通用的对象，这些对象用来处理我们的一些通用的过程。 /*通用验证对象*/ var validator = { validateName : function(){ console.log(this.name); }, validateAge : function(){ console.log(this.age) } //..... } /*对象kobe*/ var kobe = { name : &apos;kobe bryant&apos;, age : -1 } /*对象 allen*/ var allen = { name : &apos;allen iverson&apos;, age : 10 } var isKobeAgeValid = validator.call(kobe); var isAllenAgeValid = validator.call(allen); 用处与区别 call, apply作用就是借用别人的方法来调用,就像调用自己的一样. call, apply方法区别是,从第二个参数起, call方法参数将依次传递给借用的方法作参数, 而apply直接将这些参数放到一个数组中再传递, 最后借用方法的参数列表是一样的。","tags":[{"name":"call/apply","slug":"call-apply","permalink":"http://feixiaoxiaojia.github.io/tags/call-apply/"}]},{"title":"Hello World","date":"2017-07-19T02:24:04.185Z","path":"2017/07/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"随笔","slug":"随笔","permalink":"http://feixiaoxiaojia.github.io/tags/随笔/"}]},{"title":"JS中的计时器方法","date":"2017-07-16T10:02:00.000Z","path":"2017/07/16/countClock/","text":"题目描述实现一个打点计时器，要求 1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 1 2、返回的对象中需要包含一个 cancel 方法，用于停止定时操作3、第一个数需要立即输出 思路 方法描述setInterval周期性的调用一个函数(function)或者执行一段代码clearInterval取消调用setInterval设置的重复执行动作setTimeout在指定的延迟时间之后调用一个函数(function)或者执行一段代码片段clearTimeout方法可取消由setTimeout方法设置的timeout 例子var id=setInterval(function(){ consoel.log(&quot;log&quot;) },1000) clearInterval(id); var id=setTimeout(function() { alert(&quot;Hello World!&quot;); }, 500); clearTimeout(id); 提示：setTimeout()止执行一次code。如果要多次调用，可以使用setInterval()或者让code自身再次调用setTimeout(). 解题方法setInterval方法function count(start, end) { console.log(start); var id=setInterval(function(){ if(start&lt;end){ console.log(++start); } },100); return { cancel:function(){ clearInterval(id); } } } //测试调用 var cancel=count(1,1000); cancel.cancel();//即可停止计数 setTimeout方法function count(start,end){ if(start&lt;=end){ console.log(start++); id=setTimeout(function(){ count(start,end); },100); } return { cancel:function(){ clearTimeout(id); } } } //测试调用 var cancel=count(1,1000); cancel.cancel();//即可停止计数","tags":[{"name":"腾讯课堂笔试题","slug":"腾讯课堂笔试题","permalink":"http://feixiaoxiaojia.github.io/tags/腾讯课堂笔试题/"}]}]